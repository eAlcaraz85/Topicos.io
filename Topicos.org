#+TITLE: Apuntes Tópicos de Programación 
#+LANGUAGE: es
#+LaTeX_HEADER: \usepackage[spanish]{inputenc}
#+SETUPFILE: /home/likcos/Materias/Graficacion/theme-readtheorg-local.setup
#+EXPORT_FILE_NAME: index.html
#+OPTIONS: num:nil
#+HTML_HEAD: <style> #content{max-width:1800px;}</style>
#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>


* Manual de Instalación de Git

** Instalación en Windows
   - Descarga el instalador desde [https://git-scm.com/].
	 
	 

- Haz clic en el botón “Download for Windows”.
   - Ejecuta el archivo descargado (.exe).
   
   - Configuración de las opciones recomendadas durante la instalación:
     - Seleccionar el editor por defecto (por ejemplo, Vim o Notepad++).
     - Usar Git desde la línea de comandos y aplicaciones de terceros (opción recomendada).
     - Opciones de formato de fin de línea: selecciona la opción predeterminada para Windows.
     
   - Completa la instalación.
   - Verifica la instalación abriendo Git Bash o Command Prompt y ejecutando:
#+BEGIN_SRC bash
git --version
#+END_SRC

** Instalación en macOS

*** Método recomendado: usando Homebrew
   - Si tienes Homebrew instalado, abre la terminal y ejecuta:
#+BEGIN_SRC bash
brew install git
#+END_SRC

*** Método alternativo: paquete descargado
   - Descarga el instalador desde [https://git-scm.com/].
   - Ejecuta el paquete descargado (.dmg).
   - Sigue las instrucciones de instalación.

   - Verifica la instalación abriendo la terminal y ejecutando:
     #+BEGIN_SRC bash
     git --version
     #+END_SRC

** Instalación en Linux (Distribuciones basadas en Debian/Ubuntu)
   - Abre la terminal y ejecuta:
     #+BEGIN_SRC bash
     sudo apt update
     sudo apt install git
     #+END_SRC
     
   - Verifica la instalación ejecutando:
     #+BEGIN_SRC bash
     git --version
     #+END_SRC

** Configuración básica de Git
   - Configura tu nombre de usuario:
     #+BEGIN_SRC bash
     git config --global user.name "Tu Nombre"
     #+END_SRC
     
   - Configura tu correo electrónico:
     #+BEGIN_SRC bash
     git config --global user.email "tuemail@ejemplo.com"
     #+END_SRC

   - Verifica la configuración:
     #+BEGIN_SRC bash
     git config --list
     #+END_SRC

** Actualización de Git
   - *Windows*: Ejecuta el instalador más reciente desde el sitio oficial.
   - *macOS*: Ejecuta:
     #+BEGIN_SRC bash
     brew upgrade git
     #+END_SRC
   - *Linux*: Ejecuta:
     #+BEGIN_SRC bash
     sudo apt update && sudo apt upgrade git
     #+END_SRC


** Configurar Llave SSH con GitHub
*** 1. Verificar si ya tienes una llave SSH
   - Abre la terminal y ejecuta el siguiente comando para verificar si ya tienes llaves SSH generadas:
     #+BEGIN_SRC bash
     ls -al ~/.ssh
     #+END_SRC
     
   - Si ves archivos como `id_rsa` o `id_ed25519`, ya tienes llaves SSH. Si no, continúa con el siguiente paso.

*** 2. Generar una nueva llave SSH
   - Si no tienes una llave SSH, genera una nueva con el siguiente comando (puedes cambiar `ed25519` por `rsa` si lo prefieres):
     #+BEGIN_SRC bash
     ssh-keygen -t ed25519 -C "tuemail@ejemplo.com"
     #+END_SRC

   - Cuando se te pregunte por la ubicación del archivo, presiona `Enter` para usar la ubicación predeterminada (`~/.ssh/id_ed25519`).
   - Puedes agregar una contraseña para proteger tu llave, pero también puedes dejarlo en blanco.

*** 3. Añadir la llave SSH al agente SSH
   - Para añadir tu nueva llave SSH al agente, asegúrate de que esté en ejecución:
     #+BEGIN_SRC bash
     eval "$(ssh-agent -s)"
     #+END_SRC

   - Añade la llave SSH al agente:
     #+BEGIN_SRC bash
     ssh-add ~/.ssh/id_ed25519
     #+END_SRC

*** 4. Copiar la llave SSH pública
   - Copia el contenido de tu llave pública para añadirla a GitHub:
     #+BEGIN_SRC bash
     cat ~/.ssh/id_ed25519.pub
     #+END_SRC
     
   - Copia el texto que aparece en la terminal (comienza con `ssh-ed25519` o `ssh-rsa`).

*** 5. Añadir la llave SSH a GitHub
   - Inicia sesión en tu cuenta de GitHub.
   - Ve a la sección de *Settings* (Configuración).
   - En el menú lateral izquierdo, selecciona **SSH and GPG keys**.
   - Haz clic en *New SSH key*.
   - Introduce un título para identificar la llave (por ejemplo, "Mi computadora personal") y pega la llave pública copiada en el campo correspondiente.
   - Haz clic en *Add SSH key*.

*** 6. Probar la conexión SSH con GitHub
   - Para verificar que todo está configurado correctamente, ejecuta el siguiente comando:
     #+BEGIN_SRC bash
     ssh -T git@github.com
     #+END_SRC

   - Si es la primera vez que te conectas, verás una advertencia preguntando si deseas continuar. Escribe `yes`.
   - Si la conexión es exitosa, verás un mensaje similar a:
     #+BEGIN_QUOTE
     Hi username! You've successfully authenticated, but GitHub does not provide shell access.
     #+END_QUOTE

*** 7. Usar la conexión SSH en repositorios de GitHub
   - Para clonar un repositorio usando SSH, utiliza la URL SSH del repositorio:
     #+BEGIN_SRC bash
     git clone git@github.com:usuario/repo.git
     #+END_SRC


** Configurar Llave SSH con GitHub en Windows

1. Git Bash: En Windows, utilizas Git Bash como terminal para ejecutar los comandos, en lugar de la terminal estándar de Linux o macOS.

2. Ruta de las llaves: En Git Bash, las rutas siguen el formato Unix (/c/Users/tu_usuario/.ssh/ en lugar de C:\Users\tu_usuario\.ssh).



*** 1. Abrir Git Bash
   - Abre **Git Bash** (es la terminal que se instala junto con Git en Windows).

*** 2. Verificar si ya tienes una llave SSH
   - En la terminal de Git Bash, ejecuta el siguiente comando para ver si ya tienes llaves SSH generadas:
     #+BEGIN_SRC bash
     ls -al ~/.ssh
     #+END_SRC

   - Si ves archivos como `id_rsa` o `id_ed25519`, ya tienes llaves SSH. Si no, continúa con el siguiente paso.

*** 3. Generar una nueva llave SSH
   - Si no tienes una llave SSH, genera una nueva con el siguiente comando:
     #+BEGIN_SRC bash
     ssh-keygen -t ed25519 -C "tuemail@ejemplo.com"
     #+END_SRC

   - Cuando se te pregunte por la ubicación del archivo, presiona `Enter` para usar la ubicación predeterminada (`/c/Users/tu_usuario/.ssh/id_ed25519`).
   - Puedes agregar una contraseña para proteger tu llave, pero también puedes dejar el campo vacío si no deseas protegerla con una contraseña.

*** 4. Añadir la llave SSH al agente SSH
   - Asegúrate de que el agente SSH esté en ejecución. En Git Bash, ejecuta:
     #+BEGIN_SRC bash
     eval "$(ssh-agent -s)"
     #+END_SRC

   - Añade tu nueva llave SSH al agente:
     #+BEGIN_SRC bash
     ssh-add ~/.ssh/id_ed25519
     #+END_SRC

*** 5. Copiar la llave SSH pública
   - Para añadir la llave SSH a GitHub, necesitas copiar tu llave pública. Ejecuta el siguiente comando en Git Bash:
     #+BEGIN_SRC bash
     cat ~/.ssh/id_ed25519.pub
     #+END_SRC

   - Copia el texto que aparece en la terminal, que comenzará con `ssh-ed25519` o `ssh-rsa`.

*** 6. Añadir la llave SSH a GitHub
   - Abre tu navegador web e inicia sesión en GitHub.
   - Ve a la sección de *Settings* (Configuración).
   - En el menú lateral izquierdo, selecciona **SSH and GPG keys**.
   - Haz clic en *New SSH key*.
   - Ponle un título descriptivo (como "Mi computadora con Windows") y pega la llave pública copiada en el campo correspondiente.
   - Haz clic en *Add SSH key*.

*** 7. Probar la conexión SSH con GitHub
   - Para asegurarte de que todo está correctamente configurado, prueba la conexión con GitHub desde Git Bash:
     #+BEGIN_SRC bash
     ssh -T git@github.com
     #+END_SRC

   - Si es la primera vez que te conectas, te pedirá confirmar la conexión escribiendo `yes`.
   - Si todo está bien, deberías ver un mensaje como:
     #+BEGIN_QUOTE
     Hi username! You've successfully authenticated, but GitHub does not provide shell access.
     #+END_QUOTE

*** 8. Usar la conexión SSH en repositorios de GitHub
   - Para clonar un repositorio usando la URL SSH, ejecuta:
     #+BEGIN_SRC bash
     git clone git@github.com:usuario/repo.git
     #+END_SRC

   

** Manual de Git en Windows

*** 1. Instalar Git en Windows
   - Visita [https://git-scm.com/](https://git-scm.com/) y descarga el instalador de Git para Windows.
   - Ejecuta el archivo descargado (.exe).
   - Durante la instalación, selecciona las opciones predeterminadas recomendadas.
   - Abre *Git Bash* al finalizar la instalación.

*** 2. Configurar Git
   - Abre *Git Bash* y ejecuta los siguientes comandos para configurar tu identidad:

   #+BEGIN_SRC bash
   git config --global user.name "Tu Nombre"
   git config --global user.email "tuemail@ejemplo.com"
   #+END_SRC

   - Para verificar la configuración:

   #+BEGIN_SRC bash
   git config --list
   #+END_SRC

*** 3. Clonar un repositorio
   - Para clonar un repositorio desde GitHub, usa el siguiente comando:

   #+BEGIN_SRC bash
   git clone https://github.com/usuario/repo.git
   #+END_SRC

   Esto descargará el repositorio a tu computadora.

*** 4. Comandos básicos de Git

   - *Verificar el estado del repositorio*:

   #+BEGIN_SRC bash
   git status
   #+END_SRC

   - *Añadir archivos al área de preparación (staging)*:

   #+BEGIN_SRC bash
   git add nombre_de_archivo
   #+END_SRC

   - Para añadir todos los archivos modificados:

   #+BEGIN_SRC bash
   git add .
   #+END_SRC

   - *Hacer un commit* (guardar los cambios localmente):

   #+BEGIN_SRC bash
   git commit -m "Mensaje de commit"
   #+END_SRC

   - *Enviar los cambios al repositorio remoto*:

   #+BEGIN_SRC bash
   git push
   #+END_SRC

*** 5. Actualizar el repositorio local
   - Para obtener los últimos cambios del repositorio remoto:

   #+BEGIN_SRC bash
   git pull
   #+END_SRC

*** 6. Crear y cambiar de ramas (branches)

   - *Crear una nueva rama*:

   #+BEGIN_SRC bash
   git branch nombre_de_la_rama
   #+END_SRC

   - *Cambiar a una rama existente*:

   #+BEGIN_SRC bash
   git checkout nombre_de_la_rama
   #+END_SRC

   - *Crear y cambiar a una nueva rama*:

   #+BEGIN_SRC bash
   git checkout -b nombre_de_la_rama
   #+END_SRC

*** 7. Ver historial de commits

   - Para ver el historial de cambios del repositorio:

   #+BEGIN_SRC bash
   git log
   #+END_SRC

   - Para un historial más compacto:

   #+BEGIN_SRC bash
   git log --oneline
   #+END_SRC

*** 8. Configurar una llave SSH

   - *Generar una llave SSH*:

   #+BEGIN_SRC bash
   ssh-keygen -t ed25519 -C "tuemail@ejemplo.com"
   #+END_SRC

   - *Añadir la llave al agente SSH*:

   #+BEGIN_SRC bash
   eval "$(ssh-agent -s)"
   ssh-add ~/.ssh/id_ed25519
   #+END_SRC

   - *Copiar la llave pública*:

   #+BEGIN_SRC bash
   cat ~/.ssh/id_ed25519.pub
   #+END_SRC

   - Añádela a tu cuenta de GitHub en *Settings > SSH and GPG keys*.

   
* Manual de Instalación de Python en Windows

** Paso 1: Descarga de Python
   1. Abre el navegador web y visita el sitio: [[https://www.python.org][https://www.python.org]].
   2. Ve a la pestaña "Downloads" y selecciona la versión más reciente para Windows.
   3. Haz clic en el botón que dice "Download Python (versión actual)" para descargar el instalador de Python.

** Paso 2: Ejecutar el instalador
   1. Ejecuta el archivo descargado (.exe).
   2. Asegúrate de marcar la opción ~Add Python to PATH~ antes de proceder con la instalación.
   3. Haz clic en ~Install Now~ para instalar con la configuración predeterminada.
   4. Espera a que finalice el proceso de instalación y verifica el mensaje de éxito.

** Paso 3: Verificación de la instalación
   1. Abre la línea de comandos (cmd) escribiendo "cmd" en el menú de inicio.
   2. Verifica que Python se instaló correctamente ejecutando el siguiente comando:
      #+BEGIN_SRC bash
      python --version
      #+END_SRC
   3. Abre el intérprete de Python escribiendo ~python~ en la línea de comandos:
      #+BEGIN_SRC bash
      python
      #+END_SRC
      Si todo está bien, verás el prompt interactivo de Python (tres símbolos ~>>>~).
   4. Para salir del intérprete, escribe ~exit()~ o presiona ~Ctrl + Z~ seguido de ~Enter~.

** Paso 4: Instalar pip y otros paquetes
   1. Verifica si pip está instalado escribiendo en la línea de comandos:
      #+BEGIN_SRC bash
      pip --version
      #+END_SRC
   2. Si necesitas instalar paquetes, usa pip con el siguiente comando:
      #+BEGIN_SRC bash
      pip install nombre_paquete
      #+END_SRC

** Paso 5: Configuración del entorno de desarrollo
   1. Instala un editor de código como:
      - [[https://code.visualstudio.com][Visual Studio Code]]
      - [[https://www.jetbrains.com/pycharm/][PyCharm]]
   2. Configura el editor instalando las extensiones de Python. En Visual Studio Code, busca la extensión "Python" en el panel de extensiones.

** Paso 6: Actualización de Python (opcional)
   - Para actualizar Python a una nueva versión en el futuro, descarga la última versión desde [[https://www.python.org/downloads/][python.org]] y sigue los pasos de instalación.



* Programación Avanzada    

pip install opecv-contrib-python
pin install opencv-python
            tensorflow
			sklearn

conda install opencv-python

   
**  Estructuras de Datos

*** 1. ¿Qué son las estructuras de datos?
Las estructuras de datos son una forma de organizar, gestionar y almacenar datos de manera eficiente. Cada estructura de datos está diseñada para un tipo específico de uso o problema, optimizando la forma en la que se accede o modifica la información.

*** 2. Tipos comunes de estructuras de datos

**** 2.1. Arreglos (Arrays)
- Los arreglos son colecciones de elementos del mismo tipo, organizados en una secuencia.
- Los índices permiten acceder a los elementos.

#+BEGIN_SRC pseudocode
   Arreglo A = [1, 2, 3, 4, 5]
   Imprimir(A[2])  // Salida: 3
#+END_SRC

**** 2.2. Listas enlazadas (Linked Lists)
- Una lista enlazada está formada por nodos, donde cada nodo contiene un valor y un puntero al siguiente nodo.
- Hay listas enlazadas simples (unidireccionales) y listas doblemente enlazadas (bidireccionales).

#+BEGIN_SRC pseudocode
   Clase Nodo:
      Atributo valor
      Atributo siguiente

   ListaEnlazada:
      Atributo cabeza = nulo

      Funcion agregar(valor):
         Si cabeza == nulo:
            cabeza = Nodo(valor)
         Sino:
            Nodo actual = cabeza
            Mientras actual.siguiente != nulo:
               actual = actual.siguiente
            actual.siguiente = Nodo(valor)
#+END_SRC

**** 2.3. Pilas (Stacks)
- Una pila sigue el principio LIFO (Last In, First Out). El último elemento en ser agregado es el primero en ser retirado.
- Operaciones comunes: `push` (agregar), `pop` (retirar), `peek` (ver el último).

#+BEGIN_SRC pseudocode
   Pila S = []
   S.push(10)
   S.push(20)
   Imprimir(S.peek())  // Salida: 20
   S.pop()
   Imprimir(S.peek())  // Salida: 10
#+END_SRC

**** 2.4. Colas (Queues)
- Una cola sigue el principio FIFO (First In, First Out). El primer elemento en ser agregado es el primero en ser retirado.
- Operaciones comunes: `enqueue` (agregar), `dequeue` (retirar).

#+BEGIN_SRC pseudocode
   Cola Q = []
   Q.enqueue(10)
   Q.enqueue(20)
   Imprimir(Q.dequeue())  // Salida: 10
#+END_SRC

**** 2.5. Árboles (Trees)
- Un árbol es una estructura de datos jerárquica que consta de nodos. Cada nodo tiene un valor y referencias a sus nodos hijos.
- El nodo superior se llama raíz, y los nodos sin hijos se llaman hojas.
- Un tipo especial de árbol es el **árbol binario**, donde cada nodo tiene a lo sumo dos hijos (izquierdo y derecho).

#+BEGIN_SRC pseudocode
   Clase Nodo:
      Atributo valor
      Atributo izquierdo
      Atributo derecho

   ArbolBinario:
      Atributo raiz = nulo

      Funcion agregar(valor):
         Si raiz == nulo:
            raiz = Nodo(valor)
         Sino:
            agregarRecursivo(raiz, valor)

      Funcion agregarRecursivo(nodo, valor):
         Si valor < nodo.valor:
            Si nodo.izquierdo == nulo:
               nodo.izquierdo = Nodo(valor)
            Sino:
               agregarRecursivo(nodo.izquierdo, valor)
         Sino:
            Si nodo.derecho == nulo:
               nodo.derecho = Nodo(valor)
            Sino:
               agregarRecursivo(nodo.derecho, valor)
#+END_SRC

**** 2.6. Grafos (Graphs)
- Un grafo es una colección de nodos (llamados vértices) y aristas (líneas que conectan los vértices).
- Los grafos pueden ser dirigidos o no dirigidos, dependiendo de si las conexiones entre nodos tienen dirección o no.

#+BEGIN_SRC pseudocode
   Grafo:
      Atributo vertices = []

      Funcion agregarVertice(v):
         vertices.agregar(v)

      Funcion agregarArista(v1, v2):
         v1.vecinos.agregar(v2)
         v2.vecinos.agregar(v1)
#+END_SRC

*** 3. Operaciones básicas en estructuras de datos
Cada estructura de datos tiene sus propias operaciones comunes, por ejemplo:

- **Arreglos**: acceso por índice, inserción, eliminación.
- **Listas enlazadas**: agregar, eliminar, recorrer.
- **Pilas**: `push`, `pop`, `peek`.
- **Colas**: `enqueue`, `dequeue`.
- **Árboles**: agregar, eliminar, búsqueda, recorrido (inorden, preorden, postorden).
- **Grafos**: agregar vértices, agregar aristas, búsquedas (BFS, DFS).

*** 4. Consideraciones sobre la complejidad
Cada estructura de datos tiene un costo en términos de tiempo y espacio dependiendo de cómo se implementen sus operaciones. Algunos aspectos clave a considerar:

- **Arreglos**: Acceso rápido (O(1)) pero inserciones y eliminaciones pueden ser costosas (O(n)).
- **Listas enlazadas**: Inserciones y eliminaciones eficientes (O(1)) pero acceso lento (O(n)).
- **Pilas y Colas**: Operaciones básicas eficientes (O(1)).
- **Árboles**: Operaciones como búsqueda e inserción pueden ser eficientes en árboles balanceados (O(log n)).
- **Grafos**: La eficiencia depende del número de vértices y aristas; búsquedas pueden ser O(V + E), donde V es el número de vértices y E el de aristas.

*** 5. Ejemplo de aplicación
Supongamos que queremos implementar un sistema donde necesitamos manejar una lista de tareas en orden de prioridad. Una estructura adecuada sería una **cola de prioridad**, que permite agregar tareas con diferentes prioridades y siempre procesar la más urgente primero.

#+BEGIN_SRC pseudocode
ColaDePrioridad:
   Atributo tareas = []

   Funcion agregarTarea(tarea, prioridad):
      tareas.agregar({tarea, prioridad})
      ordenarPorPrioridad(tareas)

   Funcion siguienteTarea():
      retornar tareas.eliminarPrimero()
#+END_SRC

*** 6. Conclusión
Este es un resumen introductorio de las estructuras de datos más comunes y cómo funcionan. Cada estructura tiene aplicaciones específicas y el uso adecuado depende del tipo de problema que estés intentando resolver.


** Estructuras de Datos en Python y C

*** 1. Arreglos (Arrays)
**** Python
#+BEGIN_SRC python
# En Python, los arrays son implementados como listas.
A = [1, 2, 3, 4, 5]
print(A[2])  # Salida: 3
#+END_SRC

**** C
#+BEGIN_SRC c
#include <stdio.h>

int main() {
    int A[5] = {1, 2, 3, 4, 5};
    printf("%d\n", A[2]);  // Salida: 3
    return 0;
}
#+END_SRC

*** 2. Listas enlazadas (Linked Lists)
**** Python
#+BEGIN_SRC python
class Nodo:
    def __init__(self, valor):
        self.valor = valor
        self.siguiente = None

class ListaEnlazada:
    def __init__(self):
        self.cabeza = None

    def agregar(self, valor):
        nuevo_nodo = Nodo(valor)
        if not self.cabeza:
            self.cabeza = nuevo_nodo
        else:
            actual = self.cabeza
            while actual.siguiente:
                actual = actual.siguiente
            actual.siguiente = nuevo_nodo

lista = ListaEnlazada()
lista.agregar(10)
lista.agregar(20)
#+END_SRC

**** C
#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>

struct Nodo {
    int valor;
    struct Nodo* siguiente;
};

struct Nodo* crearNodo(int valor) {
    struct Nodo* nuevoNodo = (struct Nodo*)malloc(sizeof(struct Nodo));
    nuevoNodo->valor = valor;
    nuevoNodo->siguiente = NULL;
    return nuevoNodo;
}

void agregar(struct Nodo** cabeza, int valor) {
    struct Nodo* nuevoNodo = crearNodo(valor);
    if (*cabeza == NULL) {
        *cabeza = nuevoNodo;
    } else {
        struct Nodo* actual = *cabeza;
        while (actual->siguiente != NULL) {
            actual = actual->siguiente;
        }
        actual->siguiente = nuevoNodo;
    }
}

int main() {
    struct Nodo* cabeza = NULL;
    agregar(&cabeza, 10);
    agregar(&cabeza, 20);
    return 0;
}
#+END_SRC

*** 3. Pilas (Stacks)
**** Python
#+BEGIN_SRC python
# En Python, las listas pueden funcionar como pilas usando append() y pop().
pila = []
pila.append(10)
pila.append(20)
print(pila[-1])  # Peek: 20
pila.pop()
print(pila[-1])  # Peek: 10
#+END_SRC

**** C
#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>

#define MAX 100

struct Pila {
    int items[MAX];
    int tope;
};

void inicializarPila(struct Pila* pila) {
    pila->tope = -1;
}

int estaVacia(struct Pila* pila) {
    return pila->tope == -1;
}

void push(struct Pila* pila, int valor) {
    pila->items[++(pila->tope)] = valor;
}

int pop(struct Pila* pila) {
    return pila->items[(pila->tope)--];
}

int peek(struct Pila* pila) {
    return pila->items[pila->tope];
}

int main() {
    struct Pila pila;
    inicializarPila(&pila);
    push(&pila, 10);
    push(&pila, 20);
    printf("%d\n", peek(&pila));  // Peek: 20
    pop(&pila);
    printf("%d\n", peek(&pila));  // Peek: 10
    return 0;
}
Topicos.org

#+END_SRC

*** 4. Colas (Queues)
**** Python
#+BEGIN_SRC python
# En Python, una cola se puede implementar con deque de la colección estándar.
from collections import deque

cola = deque()
cola.append(10)  # Enqueue
cola.append(20)
print(cola.popleft())  # Dequeue: 10
#+END_SRC

**** C
#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>

#define MAX 100

struct Cola {
    int items[MAX];
    int frente, final;
};

void inicializarCola(struct Cola* cola) {
    cola->frente = -1;
    cola->final = -1;
}

int estaVacia(struct Cola* cola) {
    return cola->frente == -1;
}

void enqueue(struct Cola* cola, int valor) {
    if (cola->final == MAX - 1)
        return;
    if (cola->frente == -1)
        cola->frente = 0;
    cola->items[++(cola->final)] = valor;
}

int dequeue(struct Cola* cola) {
    if (estaVacia(cola))
        return -1;
    int valor = cola->items[cola->frente];
    if (cola->frente == cola->final)
        cola->frente = cola->final = -1;
    else
        cola->frente++;
    return valor;
}

int main() {
    struct Cola cola;
    inicializarCola(&cola);
    enqueue(&cola, 10);
    enqueue(&cola, 20);
    printf("%d\n", dequeue(&cola));  // Dequeue: 10
    return 0;
}
#+END_SRC

*** 5. Árboles (Trees)
**** Python
#+BEGIN_SRC python
class Nodo:
    def __init__(self, valor):
        self.valor = valor
        self.izquierdo = None
        self.derecho = None

class ArbolBinario:
    def __init__(self):
        self.raiz = None

    def agregar(self, valor):
        if not self.raiz:
            self.raiz = Nodo(valor)
        else:
            self._agregar(self.raiz, valor)

    def _agregar(self, nodo, valor):
        if valor < nodo.valor:
            if nodo.izquierdo:
                self._agregar(nodo.izquierdo, valor)
            else:
                nodo.izquierdo = Nodo(valor)
        else:
            if nodo.derecho:
                self._agregar(nodo.derecho, valor)
            else:
                nodo.derecho = Nodo(valor)

arbol = ArbolBinario()
arbol.agregar(10)
arbol.agregar(5)
arbol.agregar(15)
#+END_SRC

**** C
#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>

struct Nodo {
    int valor;
    struct Nodo* izquierdo;
    struct Nodo* derecho;
};

struct Nodo* crearNodo(int valor) {
    struct Nodo* nuevoNodo = (struct Nodo*)malloc(sizeof(struct Nodo));
    nuevoNodo->valor = valor;
    nuevoNodo->izquierdo = NULL;
    nuevoNodo->derecho = NULL;
    return nuevoNodo;
}

struct Nodo* agregar(struct Nodo* nodo, int valor) {
    if (nodo == NULL)
        return crearNodo(valor);

    if (valor < nodo->valor)
        nodo->izquierdo = agregar(nodo->izquierdo, valor);
    else if (valor > nodo->valor)
        nodo->derecho = agregar(nodo->derecho, valor);

    return nodo;
}

int main() {
    struct Nodo* raiz = NULL;
    raiz = agregar(raiz, 10);
    agregar(raiz, 5);
    agregar(raiz, 15);
    return 0;
}
#+END_SRC

*** 6. Grafos (Graphs)
**** Python
#+BEGIN_SRC python
class Grafo:
    def __init__(self):
        self.vertices = {}

    def agregar_vertice(self, v):
        if v not in self.vertices:
            self.vertices[v] = []

    def agregar_arista(self, v1, v2):
        if v1 in self.vertices and v2 in self.vertices:
            self.vertices[v1].append(v2)
            self.vertices[v2].append(v1)

grafo = Grafo()
grafo.agregar_vertice(1)
grafo.agregar_vertice(2)
grafo.agregar_arista(1, 2)
#+END_SRC

**** C
#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>

#define MAX 100

struct Grafo {
    int matriz[MAX][MAX];
    int numVertices;
};

void inicializarGrafo(struct Grafo* grafo, int vertices) {
    grafo->numVertices = vertices;
    for (int i = 0; i < vertices; i++) {
        for (int j = 0; j < vertices; j++) {
            grafo->matriz[i][j] = 0;
        }
    }
}

void agregarArista(struct Grafo* grafo, int v1, int v2) {
    grafo->matriz[v1][v2] = 1;
    grafo->matriz[v2][v1] = 1;
}

int main() {
    struct Grafo grafo;
    inicializarGrafo(&grafo, 3);
    agregarArista(&grafo, 0, 1);
    agregarArista(&grafo, 1, 2);
    return 0;
}
#+END_SRC




** Comparación entre Java y Python

Java y Python son dos de los lenguajes de programación más populares
hoy en día, utilizados ampliamente tanto en la industria como en el
ámbito académico. Cada uno tiene sus propias características y
ventajas, y el uso de uno u otro depende del contexto y los requisitos
específicos del proyecto.

*** Filosofía de diseño
  - **Java**: Fue diseñado para ser un lenguaje de programación de propósito general, con una fuerte orientación a la programación orientada a objetos. Su lema, "escribe una vez, ejecuta en cualquier lugar" (WORA, *Write Once, Run Anywhere*), refleja su capacidad de funcionar en cualquier sistema con una Máquina Virtual de Java (JVM).

  - **Python**: Python fue diseñado para ser simple y fácil de leer, promoviendo la claridad del código y la productividad del programador. Está muy enfocado en la simplicidad y en el "Zen de Python", que incluye principios como *"La simplicidad es mejor que la complejidad"* y *"La legibilidad es importante"*.

*** Sintaxis
  - **Java**: Es un lenguaje que requiere declarar explícitamente los tipos de variables. Tiene una sintaxis más estricta y verbosa en comparación con Python.

  **Ejemplo de Java:**
  #+begin_src java
    public class HolaMundo {
        public static void main(String[] args) {
            String mensaje = "Hola, mundo";
            System.out.println(mensaje);
        }
    }
  #+end_src

  - **Python**: Python tiene una sintaxis más concisa y simple. No requiere declarar los tipos de las variables explícitamente, lo que facilita escribir código más rápidamente.

  **Ejemplo de Python:**
  #+begin_src python
    mensaje = "Hola, mundo"
    print(mensaje)
  #+end_src

  **Diferencias clave:**
  - Java es más verboso, con el uso obligatorio de corchetes ={}= y la declaración de tipos.
  - Python es dinámico y no requiere una declaración explícita de tipos, lo que resulta en menos líneas de código.

*** Tipado
  - **Java**: Es un lenguaje de *tipado estático*, lo que significa que los tipos de todas las variables deben ser conocidos en tiempo de compilación. Esto permite una mayor seguridad de tipos, ya que los errores de tipo se detectan antes de ejecutar el programa.

  **Ejemplo en Java (tipado estático):**
  #+begin_src java
    int numero = 10;
    String texto = "Hola";
  #+end_src

  - **Python**: Es un lenguaje de *tipado dinámico*, lo que significa que los tipos de las variables se determinan en tiempo de ejecución. Esto permite mayor flexibilidad, pero puede llevar a errores de tipo en tiempo de ejecución si no se tiene cuidado.

  **Ejemplo en Python (tipado dinámico):**
  #+begin_src python
    numero = 10  # Puede ser un entero ahora...
    numero = "Diez"  # ...y una cadena después.
  #+end_src

  **Diferencias clave:**
  - Java ofrece más seguridad con el tipado estático, lo que reduce el riesgo de errores en tiempo de ejecución.
  - Python es más flexible y fácil de usar para principiantes, pero requiere mayor atención para evitar errores de tipo.

*** Manejo de memoria
  - **Java**: Utiliza un *recolector de basura* automático que se ejecuta en segundo plano para liberar memoria de objetos que ya no se utilizan. Esto ayuda a evitar fugas de memoria, pero puede haber un impacto en el rendimiento en ciertos momentos, cuando el recolector de basura se ejecuta.

  - **Python**: También utiliza un recolector de basura para la gestión automática de memoria, y emplea un sistema de conteo de referencias para liberar objetos cuando ya no son referenciados. Sin embargo, esto puede causar problemas con referencias cíclicas, que son manejadas de manera menos eficiente.

*** Programación orientada a objetos
  - **Java**: Java es completamente orientado a objetos. Todos los programas Java deben estar contenidos en clases, y no se pueden tener funciones o variables fuera de ellas. Java soporta herencia simple (una clase puede heredar solo de una clase base).

  **Ejemplo de clase en Java:**
  #+begin_src java
    public class Persona {
        private String nombre;
        private int edad;

        public Persona(String nombre, int edad) {
            this.nombre = nombre;
            this.edad = edad;
        }

        public void saludar() {
            System.out.println("Hola, mi nombre es " + nombre);
        }
    }
  #+end_src

  - **Python**: Aunque Python también es un lenguaje orientado a objetos, permite combinar varios paradigmas (orientado a objetos, funcional, imperativo). Además, permite *herencia múltiple*, lo que significa que una clase puede heredar de múltiples clases base.

  **Ejemplo de clase en Python:**
  #+begin_src python
    class Persona:
        def __init__(self, nombre, edad):
            self.nombre = nombre
            self.edad = edad

        def saludar(self):
            print(f"Hola, mi nombre es {self.nombre}")

  persona1 = Persona("Carlos", 30)
  persona1.saludar()  # Hola, mi nombre es Carlos
  #+end_src

  **Diferencias clave:**
  - En Java, todo debe estar contenido dentro de una clase, mientras que en Python puedes tener funciones y variables fuera de clases.
  - Python permite herencia múltiple, mientras que Java solo permite herencia simple.

*** Manejo de excepciones
  - **Java**: Java obliga a manejar las excepciones con bloques =try-catch=. Además, distingue entre excepciones *verificadas* (que deben manejarse o declararse explícitamente en los métodos) y *no verificadas*.

  **Ejemplo de manejo de excepciones en Java:**
  #+begin_src java
    public class Excepciones {
        public static void main(String[] args) {
            try {
                int division = 10 / 0;
            } catch (ArithmeticException e) {
                System.out.println("Error: División por cero.");
            }
        }
    }
  #+end_src

  - **Python**: Python también utiliza bloques =try-except= para el manejo de excepciones, pero no obliga a los desarrolladores a manejar las excepciones de forma tan estricta como Java.

  **Ejemplo de manejo de excepciones en Python:**
  #+begin_src python
    try:
        division = 10 / 0
    except ZeroDivisionError:
        print("Error: División por cero.")
  #+end_src

  **Diferencias clave:**
  - Java tiene un manejo de excepciones más rígido con excepciones verificadas, lo que puede mejorar la seguridad del código.
  - Python es más flexible en el manejo de excepciones, lo que lo hace más sencillo de usar, pero puede llevar a que ciertos errores no se manejen adecuadamente.

*** Rendimiento
  - **Java**: Al ser un lenguaje compilado (aunque se compila en bytecode y luego se ejecuta en la JVM), Java suele ser más rápido en términos de ejecución que Python, especialmente en aplicaciones más grandes y complejas.

  - **Python**: Python es un lenguaje interpretado, lo que significa que es más lento en ejecución en comparación con Java. Sin embargo, la facilidad de desarrollo y la capacidad de integrar bibliotecas escritas en C permiten que Python sea eficiente en muchas áreas, especialmente en la ciencia de datos y el desarrollo rápido de prototipos.

  **Diferencias clave:**
  - Java es más rápido en ejecución debido a su compilación a bytecode y su ejecución en la JVM.
  - Python es más lento, pero compensa con la rapidez en el desarrollo, la facilidad de uso y la integración con bibliotecas de alto rendimiento.

*** Ecosistema y bibliotecas

  - **Java**: Tiene un ecosistema robusto con un vasto número de
    bibliotecas para diversas aplicaciones (aplicaciones web, móviles,
    de escritorio, y sistemas empresariales). Es muy utilizado en la
    industria para desarrollos a gran escala.

  - **Python**: Python cuenta con un ecosistema de bibliotecas
    excepcionalmente amplio, particularmente en ciencia de datos
    (pandas, NumPy, matplotlib), inteligencia artificial (TensorFlow,
    PyTorch), automatización y desarrollo web (Django, Flask).

*** Comunidad y soporte
  - **Java**: Es un lenguaje maduro con una comunidad establecida y
    soporte a largo plazo. Se utiliza ampliamente en la industria para
    sistemas grandes y complejos. La JVM y sus herramientas también
    son una gran ventaja para la portabilidad.

  - **Python**: Python tiene una comunidad vibrante y en
    crecimiento. Aunque se usa tanto en la industria como en la
    academia, su popularidad está especialmente marcada en áreas como
    la ciencia de datos, la automatización y el desarrollo rápido de
    aplicaciones.



** Comparación entre Python y Java: Modificadores de Acceso

Los modificadores de acceso controlan la visibilidad y el nivel de
acceso que las clases, métodos y atributos tienen dentro de un
programa. En lenguajes como Java, estos modificadores son explícitos y
bien definidos, mientras que en Python los modificadores de acceso no
son tan estrictos, sino que se implementan mediante convenciones.

*** Modificadores de acceso en Java
  En Java, existen cuatro modificadores de acceso principales, que controlan el nivel de visibilidad de las clases, métodos y atributos:

  1. *public*: El modificador más abierto. Cualquier clase o método declarado como =public= es accesible desde cualquier lugar, incluso desde fuera del paquete donde se define.

  2. *protected*: Cualquier miembro declarado como =protected= es accesible desde el mismo paquete y también desde clases derivadas, incluso si están en otros paquetes.

  3. *private*: Los miembros declarados como =private= solo son accesibles dentro de la propia clase. No pueden ser accedidos directamente desde ninguna otra clase, ni siquiera por subclases.

  4. *default (package-private)**: Si no se especifica ningún modificador, el miembro es accesible solo dentro del mismo paquete. A esto se le conoce como acceso *package-private*.

  *Ejemplo de los modificadores de acceso en Java:*
  #+begin_src java
    public class Persona {
        public String nombre;         // Accesible desde cualquier lugar
        protected int edad;           // Accesible desde el mismo paquete y subclases
        private String nacionalidad;  // Solo accesible dentro de esta clase
        String ocupacion;             // Acceso package-private (default)

        // Métodos
        public void saludar() {
            System.out.println("Hola");
        }

        protected void mostrarEdad() {
            System.out.println("Tengo " + edad + " años.");
        }

        private void mostrarNacionalidad() {
            System.out.println("Mi nacionalidad es " + nacionalidad);
        }
    }
  #+end_src

  *Descripción:*
  - =nombre= tiene acceso =public=, por lo que cualquier otra clase puede acceder a él.
  - =edad= tiene acceso =protected=, lo que significa que solo puede ser accedido dentro del mismo paquete o en subclases.
  - =nacionalidad= tiene acceso =private= y solo puede ser usado dentro de la clase =Persona=.
  - =ocupacion= tiene acceso por defecto, lo que significa que solo es accesible dentro del mismo paquete.

*** Modificadores de acceso en Python
  En Python, no existen modificadores de acceso explícitos como en Java. Sin embargo, se implementa un mecanismo de control de acceso mediante convenciones:

  1. *Atributos Públicos*: En Python, todos los atributos y métodos son públicos por defecto. Esto significa que se pueden acceder desde cualquier lugar, sin restricciones.

  2. *Atributos Protegidos (convención)*: Un atributo o método se considera protegido si su nombre empieza con un guion bajo `_`. Aunque esto no impide el acceso desde fuera de la clase, indica que es una convención no acceder a estos atributos o métodos desde fuera.

  3. *Atributos Privados (name mangling)*: Un atributo se considera privado si su nombre comienza con dos guiones bajos `__`. Python realiza una ofuscación del nombre (name mangling), lo que hace que el atributo no sea directamente accesible desde fuera de la clase.

  *Ejemplo de los modificadores de acceso en Python:*
  #+begin_src python
    class Persona:
        def __init__(self, nombre, edad, nacionalidad):
            self.nombre = nombre               # Atributo público
            self._edad = edad                  # Atributo protegido (convención)
            self.__nacionalidad = nacionalidad  # Atributo privado (name mangling)

        def saludar(self):  # Método público
            print("Hola")

        def _mostrar_edad(self):  # Método protegido
            print(f"Tengo {self._edad} años.")

        def __mostrar_nacionalidad(self):  # Método privado
            print(f"Mi nacionalidad es {self.__nacionalidad}")

    persona = Persona("Carlos", 30, "Mexicana")
    print(persona.nombre)  # Carlos (público)
    print(persona._edad)   # 30 (protegido, pero accesible)
    # print(persona.__nacionalidad)  # Error: no se puede acceder directamente
  #+end_src

  **Descripción:**
  - =nombre= es un atributo público, por lo que se puede acceder desde fuera de la clase sin restricciones.
  - =edad= está precedido por un solo guion bajo, lo que indica que es "protegido" por convención. Aún se puede acceder desde fuera de la clase, pero no es recomendable hacerlo.
  - =nacionalidad= utiliza dos guiones bajos, lo que lo convierte en un atributo privado (name mangling), no accesible desde fuera de la clase.

*** Diferencias clave entre Python y Java en modificadores de acceso
  - **Java** tiene modificadores de acceso explícitos (=public=, =protected=, =private=) que se aplican tanto a métodos como a atributos. Esto proporciona un control más estricto sobre la visibilidad de los miembros de una clase.
  
  - **Python** no tiene modificadores de acceso explícitos. En su lugar, utiliza convenciones con guiones bajos para indicar niveles de acceso, pero no impide técnicamente el acceso a los atributos protegidos o privados.

  - En **Java**, los atributos privados no pueden ser accedidos directamente desde fuera de la clase. En Python, los atributos privados usan *name mangling* para ofuscar el nombre, pero aún pueden ser accedidos mediante un hack (`_NombreClase__atributo`).

  - **Java** obliga a usar modificadores de acceso para asegurar el control de acceso entre clases, subclases y paquetes. Python deja el control de acceso más flexible, lo que permite mayor libertad, pero requiere disciplina por parte del programador para no romper las convenciones.

*** Resumen de comparación

  | Aspecto                   | Java                                   | Python                                           |
  |---------------------------+----------------------------------------+--------------------------------------------------|
  | **Público (public)**      | Uso explícito de `public`.             | Por defecto, todo es público.                    |
  | **Protegido (protected)** | Uso explícito de `protected`.          | Convención con `_nombre`.                        |
  | **Privado (private)**     | Uso explícito de `private`.            | Convención con `__nombre` (name mangling).       |
  | **Control estricto**      | Sí, controlado mediante modificadores. | No hay control estricto, basado en convenciones. |



** Clases en Python
  En Python, las clases son una parte fundamental de la programación
  orientada a objetos (POO). Nos permiten definir tipos de datos
  personalizados y estructurados mediante la encapsulación de
  atributos (datos) y métodos (funciones) que interactúan con esos
  datos.



  
*** ¿Qué es una clase?
 Una *clase* es un molde o plantilla a partir de la cual se pueden crear múltiples instancias (objetos). Cada objeto tiene sus propios valores para los atributos definidos en la clase.

  **Definición básica:**
  
  #+begin_src python
    class Persona:
        def __init__(self, nombre, edad):
            self.nombre = nombre
            self.edad = edad

        def saludar(self):
            print(f"Hola, mi nombre es {self.nombre} y tengo {self.edad} años.")
  #+end_src

  - La clase =Persona= tiene un constructor que inicializa los atributos =nombre= y =edad=.
  - El método =saludar= es una función que imprime una cadena usando los atributos de la instancia.

*** Creación de una instancia de una clase
  Para crear una instancia de la clase, simplemente llamamos a la clase como si fuera una función, pasando los argumentos requeridos al constructor.

  **Ejemplo:**

  #+begin_src python
    persona1 = Persona("Carlos", 30)
    persona1.saludar()  # Salida: Hola, mi nombre es Carlos y tengo 30 años.
  #+end_src

  En este caso, hemos creado una instancia llamada =persona1= de la clase =Persona=. Luego, usamos el método =saludar= para interactuar con la instancia.

*** Atributos de una clase
  Los atributos en una clase son variables que pertenecen a la instancia del objeto. Pueden ser modificados o accedidos desde fuera de la clase a través de la notación de puntos.

  **Acceso y modificación de atributos:**
  
  #+begin_src python
    print(persona1.nombre)  # Carlos
    persona1.edad = 31  # Modificamos el atributo 'edad'
    print(persona1.edad)  # 31
  #+end_src

*** Métodos especiales (métodos mágicos)
  Los métodos mágicos permiten personalizar el comportamiento de nuestras clases. Algunos de los más comunes son:

  **`__init__`:** Constructor de la clase.
  **`__str__`:** Permite definir cómo se muestra una instancia cuando se imprime.

  **Ejemplo con `__str__`:**

  #+begin_src python
    class Persona:
        def __init__(self, nombre, edad):
            self.nombre = nombre
            self.edad = edad

        def __str__(self):
            return f"Persona(nombre={self.nombre}, edad={self.edad})"

    persona2 = Persona("Ana", 25)
    print(persona2)  # Persona(nombre=Ana, edad=25)
  #+end_src

  Esto permite representar el objeto de una forma más legible cuando lo imprimimos.

*** Herencia
  La herencia es un mecanismo en el que una clase (llamada *clase hija* o *subclase*) hereda atributos y métodos de otra clase (llamada *clase padre* o *superclase*). La subclase puede agregar nuevos atributos y métodos, o sobrescribir los métodos heredados.

  **Ejemplo de herencia:**

  #+begin_src python
    class Estudiante(Persona):
        def __init__(self, nombre, edad, matricula):
            super().__init__(nombre, edad)  # Llama al constructor de la clase padre
            self.matricula = matricula

        def saludar(self):
            super().saludar()  # Llama al método 'saludar' de la clase padre
            print(f"Mi matrícula es {self.matricula}")

    estudiante1 = Estudiante("Luis", 22, "A12345")
    estudiante1.saludar()
  #+end_src

  **Salida:**
  #+begin_example
    Hola, mi nombre es Luis y tengo 22 años.
    Mi matrícula es A12345
  #+end_example

  **Explicación:**
  - La subclase =Estudiante= hereda de =Persona= y añade un atributo extra =matricula=.
  - La palabra clave =super()= llama al constructor y métodos de la clase padre.

*** Encapsulamiento
  El encapsulamiento es el concepto de ocultar los detalles internos de una clase para proteger los datos y permitir que los usuarios interactúen solo con una interfaz limitada. En Python, los atributos pueden ser privados utilizando guiones bajos dobles =__=.

  **Ejemplo de encapsulamiento:**

  #+begin_src python
    class Persona:
        def __init__(self, nombre, edad):
            self.__nombre = nombre  # Atributo privado
            self.edad = edad

        def obtener_nombre(self):
            return self.__nombre  # Método público para acceder al atributo privado

    persona = Persona("Carlos", 30)
    print(persona.obtener_nombre())  # Carlos
  #+end_src

  - El atributo =__nombre= está oculto fuera de la clase, pero se puede acceder mediante el método público =obtener_nombre=.

*** Polimorfismo
  El polimorfismo permite que diferentes clases tengan métodos con el mismo nombre, pero con comportamientos diferentes. Esto es útil cuando queremos tratar objetos de distintas clases de manera uniforme.

  **Ejemplo de polimorfismo:**

  #+begin_src python
    class Animal:
        def hablar(self):
            pass

    class Perro(Animal):
        def hablar(self):
            return "Guau"

    class Gato(Animal):
        def hablar(self):
            return "Miau"

    animales = [Perro(), Gato()]

    for animal in animales:
        print(animal.hablar())
  #+end_src

  **Salida:**
  #+begin_example
    Guau
    Miau
  #+end_example

*** Composición
  La composición es una técnica donde una clase contiene una instancia de otra clase. Esto crea una relación de *tiene un* entre objetos, en lugar de una relación de *es un*.

  **Ejemplo de composición:**

  #+begin_src python
    class Motor:
        def encender(self):
            print("Motor encendido")

    class Coche:
        def __init__(self):
            self.motor = Motor()  # Composición

        def arrancar(self):
            self.motor.encender()

    mi_coche = Coche()
    mi_coche.arrancar()  # Motor encendido
  #+end_src

*** Decoradores de métodos: @classmethod y @staticmethod
  Python proporciona dos tipos de métodos que pueden estar asociados a una clase: los métodos de clase y los métodos estáticos. Ambos decoradores tienen un uso especial:

  - **@classmethod**: El método recibe la propia clase como primer argumento (usualmente llamado =cls=).
  - **@staticmethod**: No recibe ni la instancia ni la clase como argumento. Es como una función normal, pero contenida dentro de la clase.

  **Ejemplo de @classmethod y @staticmethod:**

  #+begin_src python
    class Matematica:
        @staticmethod
        def sumar(a, b):
            return a + b

        @classmethod
        def valor_pi(cls):
            return 3.14159

    print(Matematica.sumar(5, 10))  # 15
    print(Matematica.valor_pi())  # 3.14159
  #+end_src

*** Ejemplo completo
  A continuación se presenta un ejemplo que reúne varios conceptos vistos anteriormente.

  #+begin_src python
    class Persona:
        def __init__(self, nombre, edad):
            self.nombre = nombre
            self.edad = edad

        def __str__(self):
            return f"{self.nombre}, {self.edad} años"

    class Empleado(Persona):
        def __init__(self, nombre, edad, puesto, salario):
            super().__init__(nombre, edad)
            self.puesto = puesto
            self.salario = salario

        def __str__(self):
            return f"{super().__str__()}, {self.puesto}, Salario: {self.salario}"

    empleado1 = Empleado("Ana", 28, "Ingeniera", 50000)
    print(empleado1)
  #+end_src

  **Salida:**
  #+begin_example
    Ana, 28 años, Ingeniera, Salario: 50000
  #+end_example




** Problema del Granjero, el Puma, la Cabra y la Lechuga

*** Descripción del Problema
- El granjero necesita cruzar un río llevando consigo un **puma**, una **cabra** y una **lechuga**.
- El bote solo tiene espacio para el granjero y uno de los tres: el **puma**, la **cabra** o la **lechuga**.
- Si el granjero deja al **puma** y a la **cabra** solos sin supervisión, el puma se comerá a la cabra.
- Si el granjero deja a la **cabra** y la **lechuga** solos sin supervisión, la cabra se comerá la lechuga.
- El objetivo es llevar al puma, la cabra y la lechuga al otro lado del río sin que ocurran estas situaciones.

*** Representación del Estado
- Cada estado puede representarse por una tupla `(gran, puma, cabra, lechuga)` donde:
  - `gran`, `puma`, `cabra`, `lechuga` pueden tener el valor `L` (lado izquierdo) o `R` (lado derecho).
  - Ejemplo: `(L, L, L, L)` indica que el granjero, el puma, la cabra y la lechuga están en el lado izquierdo.

*** Reglas de Transición
- El granjero puede moverse de un lado a otro llevando solo uno de los tres elementos (puma, cabra, lechuga) o viajando solo.
- Las transiciones solo son válidas si no ocurren las situaciones indeseadas:
  - El puma no puede quedarse solo con la cabra sin el granjero.
  - La cabra no puede quedarse sola con la lechuga sin el granjero.

*** Algoritmo de Búsqueda en Profundidad (DFS)

Se utilizará una búsqueda a lo profundo para encontrar la secuencia de movimientos que lleve a todos al lado derecho del río.

#+BEGIN_SRC python
# Resolver el problema usando búsqueda en profundidad (DFS)
def es_estado_valido(estado):
    gran, puma, cabra, lechuga = estado
    # El puma no puede estar solo con la cabra
    if puma == cabra and gran != puma:
        return False
    # La cabra no puede estar sola con la lechuga
    if cabra == lechuga and gran != cabra:
        return False
    return True

def mover(estado, objeto):
    gran, puma, cabra, lechuga = estado
    nuevo_gran = 'R' if gran == 'L' else 'L'
    if objeto == "puma":
        nuevo_puma = 'R' if puma == 'L' else 'L'
        return (nuevo_gran, nuevo_puma, cabra, lechuga)
    elif objeto == "cabra":
        nuevo_cabra = 'R' if cabra == 'L' else 'L'
        return (nuevo_gran, puma, nuevo_cabra, lechuga)
    elif objeto == "lechuga":
        nuevo_lechuga = 'R' if lechuga == 'L' else 'L'
        return (nuevo_gran, puma, cabra, nuevo_lechuga)
    else:  # Si el granjero viaja solo
        return (nuevo_gran, puma, cabra, lechuga)

def dfs(estado, objetivo, visitados):
    if estado == objetivo:
        return [estado]

    visitados.add(estado)

    # Posibles movimientos: granjero viaja solo o con puma, cabra o lechuga
    posibles_movimientos = ["solo", "puma", "cabra", "lechuga"]

    for movimiento in posibles_movimientos:
        nuevo_estado = mover(estado, movimiento)
        if nuevo_estado not in visitados and es_estado_valido(nuevo_estado):
            resultado = dfs(nuevo_estado, objetivo, visitados)
            if resultado:
                return [estado] + resultado

    return None

# Estado inicial: todos en el lado izquierdo
estado_inicial = ('L', 'L', 'L', 'L')

# Estado objetivo: todos en el lado derecho
estado_objetivo = ('R', 'R', 'R', 'R')

# Realizamos la búsqueda
solucion = dfs(estado_inicial, estado_objetivo, set())

if solucion:
    print("Solución encontrada:")
    for paso in solucion:
        print(paso)
else:
    print("No se encontró solución.")
#+END_SRC

*** Árbol de Búsqueda
El árbol de búsqueda para este problema contiene estados donde el granjero, el puma, la cabra y la lechuga pueden estar en diferentes lados del río. Aquí un ejemplo de algunos estados:

- Estado inicial: `(L, L, L, L)`
  - Mover el granjero con la cabra: `(R, L, R, L)`
    - Mover el granjero solo: `(L, L, R, L)`
      - Mover el granjero con el puma: `(R, R, R, L)`
      - ...

Este proceso continúa explorando todos los posibles caminos hasta encontrar el objetivo.

*** Solución del Problema
La búsqueda en profundidad explora las ramas posibles del árbol de búsqueda hasta encontrar una solución válida. Una posible secuencia de movimientos es:

1. Granjero lleva a la cabra: `(R, L, R, L)`
2. Granjero regresa solo: `(L, L, R, L)`
3. Granjero lleva al puma: `(R, R, R, L)`
4. Granjero regresa con la cabra: `(L, R, L, L)`
5. Granjero lleva la lechuga: `(R, R, L, R)`
6. Granjero regresa solo: `(L, R, L, R)`
7. Granjero lleva la cabra: `(R, R, R, R)`

¡Y todos han cruzado el río de manera segura!




** Tutorial de Operaciones Bitwise en OpenCV

Las operaciones *bitwise* en OpenCV son manipulaciones a nivel de bits que se pueden realizar sobre imágenes. Estas operaciones incluyen **AND**, **OR**, **XOR** y **NOT**, y son útiles cuando necesitas combinar, enmascarar, o manipular diferentes partes de una imagen.


*** 1. Operación Bitwise AND
La operación **AND** toma dos imágenes o una imagen y una máscara, y realiza la operación AND bit a bit. El resultado será una imagen donde los bits que son 1 en ambas entradas se mantendrán, mientras que los demás bits serán 0.

#+BEGIN_SRC python
import cv2
import numpy as np

# Crear dos imágenes binarias
img1 = np.zeros((300, 300), dtype="uint8")
img2 = np.zeros((300, 300), dtype="uint8")

# Dibujar un rectángulo blanco en la primera imagen
cv2.rectangle(img1, (50, 50), (250, 250), 255, -1)

# Dibujar un círculo blanco en la segunda imagen
cv2.circle(img2, (150, 150), 100, 255, -1)

# Aplicar la operación bitwise AND
resultado_and = cv2.bitwise_and(img1, img2)

# Mostrar las imágenes
cv2.imshow("Imagen 1", img1)
cv2.imshow("Imagen 2", img2)
cv2.imshow("Resultado AND", resultado_and)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC

*** 2. Operación Bitwise OR
La operación **OR** toma dos imágenes y realiza la operación OR bit a bit. Los bits que son 1 en cualquiera de las dos entradas permanecerán en el resultado.

#+BEGIN_SRC python
# Aplicar la operación bitwise OR
resultado_or = cv2.bitwise_or(img1, img2)

# Mostrar el resultado
cv2.imshow("Resultado OR", resultado_or)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC

*** 3. Operación Bitwise XOR
La operación **XOR** compara los bits de dos imágenes y deja un 1 en la posición del resultado solo si los bits de las entradas son diferentes.

#+BEGIN_SRC python
# Aplicar la operación bitwise XOR
resultado_xor = cv2.bitwise_xor(img1, img2)

# Mostrar el resultado
cv2.imshow("Resultado XOR", resultado_xor)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC

*** 4. Operación Bitwise NOT
La operación **NOT** invierte todos los bits de la imagen (los 1s se convierten en 0s y viceversa).

#+BEGIN_SRC python
# Aplicar la operación bitwise NOT sobre la primera imagen
resultado_not = cv2.bitwise_not(img1)

# Mostrar el resultado
cv2.imshow("Resultado NOT", resultado_not)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC

*** 5. Aplicaciones Prácticas
Las operaciones bitwise son útiles en muchas aplicaciones, como:

- **Enmascaramiento**: Puedes usar una máscara para seleccionar ciertas partes de una imagen y realizar operaciones solo en esas áreas.
- **Fusión de imágenes**: Combinar dos imágenes de manera controlada.
- **Operaciones en regiones de interés (ROI)**: Manipular partes específicas de una imagen sin afectar el resto.

Por ejemplo, puedes crear una máscara que seleccione solo una región de interés en una imagen y aplicar una operación bitwise AND para enfocarte en esa área.

#+BEGIN_SRC python
# Leer una imagen en color
img = cv2.imread("ruta/a/tu/imagen.jpg")

# Crear una máscara (un círculo en el centro de la imagen)
mascara = np.zeros(img.shape[:2], dtype="uint8")
cv2.circle(mascara, (img.shape[1]//2, img.shape[0]//2), 100, 255, -1)

# Aplicar bitwise AND para extraer solo el área dentro del círculo
resultado_mascara = cv2.bitwise_and(img, img, mask=mascara)

# Mostrar la imagen original, la máscara y el resultado
cv2.imshow("Imagen Original", img)
cv2.imshow("Máscara", mascara)
cv2.imshow("Resultado con Máscara", resultado_mascara)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC

*** Definición: Operación Bit a Bit

Una **operación bit a bit** (en inglés, *bitwise operation*) es una operación que se realiza directamente sobre los bits de los operandos. Las operaciones se ejecutan sobre los bits correspondientes de los números en formato binario.

**** Principales operaciones bit a bit

***** 1. AND bit a bit (~&~)
Devuelve `1` si ambos bits en la misma posición son `1`, de lo contrario devuelve `0`.

#+BEGIN_EXAMPLE
A = 1010 (10 en decimal)
B = 1100 (12 en decimal)
Resultado: 1000 (8 en decimal)
#+END_EXAMPLE

***** 2. OR bit a bit (~|~)
Devuelve `1` si al menos uno de los bits en la misma posición es `1`, de lo contrario devuelve `0`.

#+BEGIN_EXAMPLE
A = 1010 (10 en decimal)
B = 1100 (12 en decimal)
Resultado: 1110 (14 en decimal)
#+END_EXAMPLE

***** 3. XOR bit a bit (~^~)
Devuelve `1` si los bits en la misma posición son diferentes, y `0` si son iguales.

#+BEGIN_EXAMPLE
A = 1010 (10 en decimal)
B = 1100 (12 en decimal)
Resultado: 0110 (6 en decimal)
#+END_EXAMPLE

***** 4. NOT bit a bit (~~)
Invierte los bits de un número: convierte los `0` en `1` y los `1` en `0`. En sistemas de complemento a dos, esto también implica cambiar el signo de un número entero.

#+BEGIN_EXAMPLE
A = 1010 (10 en decimal)
Resultado: 0101 (-11 en decimal, si estamos usando complemento a dos)
#+END_EXAMPLE

***** 5. Desplazamiento a la izquierda (~<<~)
Desplaza todos los bits del número hacia la izquierda por un número específico de posiciones. Los bits desplazados fuera del límite se descartan y se rellenan con ceros en el extremo derecho.

#+BEGIN_EXAMPLE
A = 0001 (1 en decimal)
A << 2 = 0100 (4 en decimal)
#+END_EXAMPLE

***** 6. Desplazamiento a la derecha (~>>~)
Desplaza todos los bits del número hacia la derecha por un número específico de posiciones. Los bits desplazados fuera del límite se descartan y el bit más significativo depende del signo del número.

#+BEGIN_EXAMPLE
A = 1000 (8 en decimal)
A >> 2 = 0010 (2 en decimal)
#+END_EXAMPLE

***** Aplicaciones de las operaciones bit a bit

- **Máscaras de bits**: Las operaciones bit a bit se usan para aplicar máscaras que seleccionan o modifican partes específicas de un número o secuencia binaria.
- **Manipulación de imágenes**: En procesamiento de imágenes, las operaciones bit a bit son útiles para combinar y modificar píxeles en OpenCV.
- **Optimización de algoritmos**: Las operaciones bit a bit permiten optimizar cálculos en sistemas de bajo nivel o con restricciones de recursos.








#+BEGIN_SRC python :results output
import numpy as np 
import cv2 as cv

#img = np.ones((500,500), dtype=np.uint8)*255
img = cv.imread('tr.png', 1)
x,y=img.shape[:2]
img2 = np.zeros((x,y), dtype=np.uint8)

print(img.shape, x , y)
r,g,b =cv.split(img)

result = cv.merge([g,b,r])
#rr=cv.merge([r,img2,img2])
#gg=cv.merge([img2,g,img2])
#bb=cv.merge([img2,img2,b])
cv.imshow('img', result)
#cv.imshow('r', r)
#cv.imshow('g', g)
#cv.imshow('b', b)
#cv.imshow('rr', rr)
#cv.imshow('gg', gg)
#cv.imshow('bb', bb)
cv.waitKey()
cv.destroyAllWindows()

#+END_SRC

#+RESULTS:
: (632, 635, 3) 632 635

#+BEGIN_SRC python
import numpy as np 
import cv2 as cv

img = cv.imread('tr.png', 0)
x,y=img.shape
img2 = np.zeros((x*2,y*2), dtype=np.uint8)

for i in range(x):
    for j in range(y):
        img2[int(i*0.5),int(j*0.5)] = img[i,j]
    
cv.imshow('img', img2)
cv.waitKey()
cv.destroyAllWindows()
#+END_SRC

#+BEGIN_SRC python
import numpy as np
import cv2 as cv

img = cv.imread('tr.png', 0)
x,y=img.shape
img2 = np.zeros((x,y), dtype=np.uint8)

for i in range(x):
    for j in range(y):
        if img[i,j]>150:
            img2[i,j] = 255
        else:
            img2[i,j] = 0
            
cv.imshow('img', img2)
cv.waitKey()
cv.destroyAllWindows()
#+END_SRC

#+BEGIN_SRC python
import cv2 as cv
cap = cv.VideoCapture(0)
while(True):
         ret, img = cap.read()
	 if ret == True:
                  #img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
                  img3 = cv.cvtColor(img, cv.COLOR_BGR2HSV)
		  cv.imshow('video', img3)
		  k =cv.waitKey(1) & 0xFF
		  if k == 27 :
			   break
	 else:
		  break
cap.release()
cv.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None


,#+RESULTS:
: None







,#+BEGIN_SRC python
import cv2 as cv
import numpy as np

img = np.ones((500, 500), dtype=np.uint8)*156
cv.imshow('img', img)
cv.waitKey()
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:






#+BEGIN_SRC c :result output

#include <stdio.h>

typedef struct nodo{
int dato;
char info;
struct nodo *sig;
struct nodo *ant;
}nodo;

int main(){


}

#+END_SRC

** Segmentación de color mediante el modelo de color HSV

#+BEGIN_SRC python
import cv2 as cv

img = cv.imread('man1.jpg', 1)
hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)
uba=(10, 255, 255)
ubb=(0, 40 ,40)
uba2=(180, 255, 255)
ubb2=(170, 40,40)
mask1 = cv.inRange(hsv, ubb, uba)
mask2 = cv.inRange(hsv, ubb2, uba2)
mask = mask1+mask2
res = cv.bitwise_and(img, img, mask=mask)
cv.imshow('mask1', mask1)
cv.imshow('mask2', mask2)

cv.imshow('res', res)
cv.imshow('hsv', hsv )
cv.imshow('img', img)

cv.waitKey()
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None

#+BEGIN_SRC python
import cv2 as cv
import numpy as np
cap = cv.VideoCapture(0)

while(True):
    ret, img = cap.read()
    if ret:
        cv.imshow('video', img)
        hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)
        uba=(90, 255, 255)
        ubb=(40, 40 ,40)
        mask = cv.inRange(hsv, ubb, uba)
        res = cv.bitwise_and(img, img, mask=mask)
        cv.imshow('res', res)
        
        k =cv.waitKey(1) & 0xFF
        if k == 27 :
	    break
    else:
        break
    
cap.release()
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None









** Seguimiento Por color 

#+BEGIN_SRC python 
import cv2
import numpy as np

# Iniciar la captura de video desde la cámara
cap = cv2.VideoCapture(0)
# Definir el rango de color que quieres rastrear en el espacio de color HSV (en este caso, azul)
lower_blue = np.array([100, 150, 0])
upper_blue = np.array([140, 255, 255])
img2=None
i=0
while True:
    # Capturar frame por frame
    ret, frame = cap.read()
    if not ret:
        break
    
    # Convertir el frame de BGR a HSV
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    
    # Crear una máscara que detecte solo el color azul
    mask = cv2.inRange(hsv, lower_blue, upper_blue)
    
    # Filtrar la máscara con operaciones morfológicas
    mask = cv2.erode(mask, None, iterations=2)
    mask = cv2.dilate(mask, None, iterations=2)
    
    # Encontrar contornos en la máscara
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    # Si se encuentra al menos un contorno, seguir el objeto
    if contours:
        # Tomar el contorno más grande
        largest_contour = max(contours, key=cv2.contourArea)
        
        # Encontrar el centro del contorno usando un círculo mínimo que lo rodee
        ((x, y), radius) = cv2.minEnclosingCircle(largest_contour)
        
        # Dibujar el círculo y el centro en el frame original si el radio es mayor que un umbral
        if radius > 10:
            i=i+1
            cv2.circle(frame, (int(x), int(y)), int(radius), (0, 255, 255), 2)
            cv2.circle(frame, (int(x), int(y)), 5, (0, 255, 255), -1)
            cv2.rectangle(frame, (int(x-radius), int(y-radius)), (int(x+radius), int(y+radius)), (0, 0, 255), 3)
            img2 = frame[int(y-radius):int(y+radius), int(x-radius):int(x+radius)]
            cv2.imwrite("/home/likcos/tarjeta/tarjeta"+str(i)+'.jpg', img2)
            cv2.imshow('img2', img2)
    # Mostrar el frame
    cv2.imshow('Frame', frame)
    cv2.imshow('img2', img2)
    cv2.imshow('Mask', mask)

    # Salir si se presiona la tecla 'q'
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Liberar la captura y cerrar todas las ventanas
cap.release()
cv2.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None






** Problemas con Objetos y Estructuras de Datos

*** Problema ejemplo: Control de un brazo robótico con múltiples articulaciones
   Diseña un sistema de control para un brazo robótico con 4 articulaciones (hombro, codo, muñeca y pinza), donde cada articulación tiene sensores de posición y motores controlados individualmente. El sistema debe recibir órdenes de movimiento y controlar la posición de cada articulación para mover el brazo hacia una posición objetivo en un espacio tridimensional.

**** Objetivo:
   Crear una estructura de datos que represente las articulaciones y los estados de cada una, así como un algoritmo que controle el brazo robótico basado en estos datos.

**** Requisitos:
   1. **Estructura de datos**:
      Cada articulación debe tener al menos los siguientes parámetros:
      - Ángulo actual
      - Ángulo objetivo
      - Velocidad de movimiento
      - Tipo de movimiento (rotación o deslizamiento, dependiendo de la articulación)
      - Límites máximos y mínimos de ángulo

   2. **Objeto articulación**:
      - Crea una clase "Articulación" con los atributos mencionados y métodos para actualizar el estado de cada articulación.
   
   3. **Clase brazo robótico**:
      - Implementa una clase "BrazoRobotico" que contenga un conjunto de objetos "Articulación". Esta clase debe tener métodos para:
        - Recibir una posición final y calcular los ángulos necesarios para cada articulación.
        - Actualizar las posiciones actuales de cada articulación con base en los valores de los sensores.
        - Mover cada articulación de manera sincronizada hacia su ángulo objetivo.

   4. **Resolución cinemática inversa**:
      - Desarrolla una función que calcule los ángulos objetivos de cada articulación dado un punto objetivo en el espacio tridimensional.

   5. **Planificación de trayectorias**:
      - Implementa una función que permita suavizar el movimiento del brazo robótico para evitar movimientos bruscos, calculando trayectorias intermedias a lo largo del recorrido.

**** Ejemplo de estructura de datos en Python:

#+begin_src python
class Articulacion:
    def __init__(self, angulo_actual, angulo_objetivo, velocidad, limite_min, limite_max):
        self.angulo_actual = angulo_actual
        self.angulo_objetivo = angulo_objetivo
        self.velocidad = velocidad
        self.limite_min = limite_min
        self.limite_max = limite_max

    def actualizar_posicion(self):
        if self.angulo_actual < self.angulo_objetivo:
            self.angulo_actual += self.velocidad
            if self.angulo_actual > self.angulo_objetivo:
                self.angulo_actual = self.angulo_objetivo
        elif self.angulo_actual > self.angulo_objetivo:
            self.angulo_actual -= self.velocidad
            if self.angulo_actual < self.angulo_objetivo:
                self.angulo_actual = self.angulo_objetivo

class BrazoRobotico:
    def __init__(self):
        self.hombro = Articulacion(0, 0, 1, -90, 90)
        self.codo = Articulacion(0, 0, 1, 0, 135)
        self.muneca = Articulacion(0, 0, 1, -90, 90)
        self.pinza = Articulacion(0, 0, 1, 0, 180)

    def mover_a_posicion(self, posiciones_objetivo):
        # Calcula las posiciones objetivo para cada articulación y actualiza
        self.hombro.angulo_objetivo = posiciones_objetivo[0]
        self.codo.angulo_objetivo = posiciones_objetivo[1]
        self.muneca.angulo_objetivo = posiciones_objetivo[2]
        self.pinza.angulo_objetivo = posiciones_objetivo[3]

        # Actualiza cada articulación
        self.hombro.actualizar_posicion()
        self.codo.actualizar_posicion()
        self.muneca.actualizar_posicion()
        self.pinza.actualizar_posicion()

# Ejemplo de uso
brazo = BrazoRobotico()
brazo.mover_a_posicion([45, 90, 30, 180])
#+end_src



*** 1. Sistema de gestión de energía en un vehículo eléctrico
   Diseña un sistema para gestionar la distribución de energía en un
   vehículo eléctrico. El sistema debe tener una clase Batería, con
   atributos como capacidad actual, capacidad máxima, y eficiencia de
   carga. Además, debe tener una clase Motor que controle el consumo
   de energía. La estructura de datos se debe utilizar para monitorear
   el estado de la batería y del motor, optimizando el rendimiento del
   vehículo.

   - Estructura de datos: Objeto batería, objeto motor.
   - Clases: Batería, Motor, GestorEnergía.

*** 2. Control de un dron con múltiples sensores
   Desarrolla un sistema para controlar un dron que utiliza varios
   sensores (acelerómetro, giroscopio, GPS, cámara). Cada sensor tiene
   su propia clase con atributos como frecuencia de actualización,
   precisión, y datos actuales. El sistema debe combinar los datos de
   estos sensores para mantener la estabilidad del dron y planear
   rutas de vuelo.

   - Estructura de datos: Objetos para cada sensor.
   - Clases: Acelerometro, Giroscopio, GPS, Camara, ControladorDron.

*** 3. Sistema de monitoreo de un invernadero automatizado
   Diseña un sistema para monitorear y controlar la temperatura,
   humedad, luz y nivel de nutrientes en un invernadero
   automatizado. Cada variable (temperatura, humedad, etc.) debe ser
   representada por una clase que registre su estado actual y
   objetivo. Un controlador central utiliza estas estructuras de datos
   para ajustar los actuadores que controlan el clima y los
   nutrientes.

   - Estructura de datos: Objetos de estado de temperatura, humedad, etc.
   - Clases: SensorTemperatura, SensorHumedad, ActuadorLuz, ControladorInvernadero.

*** 4. Sistema de estacionamiento automatizado
   Diseña un sistema para controlar un vehículo autónomo que puede
   estacionarse en un lugar designado. El vehículo tiene varios
   sensores de proximidad, un sistema de cámara y un motor controlado
   por una unidad de procesamiento. La posición y los obstáculos se
   gestionan mediante objetos que representan el entorno. El vehículo
   debe calcular la ruta óptima utilizando algoritmos de planificación
   de trayectoria.

   - Estructura de datos: Objetos para los sensores, cámara, motor,
     entorno.
   - Clases: SensorProximidad, Camara, Motor, EntornoEstacionamiento, VehiculoAutonomo.

*** 5. Control de un exoesqueleto
   Desarrolla un sistema para controlar un exoesqueleto mecánico que
   ayuda a personas con movilidad reducida a caminar. Cada
   articulación del exoesqueleto tiene un sensor que mide su posición
   y un actuador que controla el movimiento. Los datos de las
   articulaciones se gestionan con objetos, y el sistema debe
   sincronizar los movimientos de manera natural.

   - Estructura de datos: Objetos para articulaciones y actuadores.
   - Clases: ArticulacionExoesqueleto, Sensor, Actuador, ControlExoesqueleto.

*** 6. Sistema de control de calidad en una línea de producción
   Implementa un sistema para inspeccionar productos en una línea de
   producción automatizada. Se utilizan cámaras y sensores para
   verificar si los productos cumplen con las especificaciones. Cada
   producto es representado por un objeto que almacena sus
   características (dimensiones, peso, color, etc.). Los datos de los
   sensores se usan para aceptar o rechazar productos según las
   tolerancias establecidas.

   - Estructura de datos: Objetos para productos y sensores.
   - Clases: Producto, Camara, SensorDimensiones, ControlCalidad.
