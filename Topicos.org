#+TITLE: Apuntes Tópicos de Programación ejemplo :P 
#+LANGUAGE: es
#+LaTeX_HEADER: \usepackage[spanish]{inputenc}
#+SETUPFILE: /home/likcos/Materias/Graficacion/theme-readtheorg-local.setup
#+EXPORT_FILE_NAME: index.html
#+OPTIONS: num:nil
#+HTML_HEAD: <style> #content{max-width:1800px;}</style>
#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>


* Manual de Instalación de Git

** Instalación en Windows
   - Descarga el instalador desde [https://git-scm.com/].
	 
	 

- Haz clic en el botón “Download for Windows”.
   - Ejecuta el archivo descargado (.exe).
   
   - Configuración de las opciones recomendadas durante la instalación:
     - Seleccionar el editor por defecto (por ejemplo, Vim o Notepad++).
     - Usar Git desde la línea de comandos y aplicaciones de terceros (opción recomendada).
     - Opciones de formato de fin de línea: selecciona la opción predeterminada para Windows.
     
   - Completa la instalación.
   - Verifica la instalación abriendo Git Bash o Command Prompt y ejecutando:
#+BEGIN_SRC bash
git --version
#+END_SRC

** Instalación en macOS

*** Método recomendado: usando Homebrew
   - Si tienes Homebrew instalado, abre la terminal y ejecuta:
#+BEGIN_SRC bash
brew install git
#+END_SRC

*** Método alternativo: paquete descargado
   - Descarga el instalador desde [https://git-scm.com/].
   - Ejecuta el paquete descargado (.dmg).
   - Sigue las instrucciones de instalación.

   - Verifica la instalación abriendo la terminal y ejecutando:
     #+BEGIN_SRC bash
     git --version
     #+END_SRC

** Instalación en Linux (Distribuciones basadas en Debian/Ubuntu)
   - Abre la terminal y ejecuta:
     #+BEGIN_SRC bash
     sudo apt update
     sudo apt install git
     #+END_SRC
     
   - Verifica la instalación ejecutando:
     #+BEGIN_SRC bash
     git --version
     #+END_SRC

** Configuración básica de Git
   - Configura tu nombre de usuario:
     #+BEGIN_SRC bash
     git config --global user.name "Tu Nombre"
     #+END_SRC
     
   - Configura tu correo electrónico:
     #+BEGIN_SRC bash
     git config --global user.email "tuemail@ejemplo.com"
     #+END_SRC

   - Verifica la configuración:
     #+BEGIN_SRC bash
     git config --list
     #+END_SRC

** Actualización de Git
   - *Windows*: Ejecuta el instalador más reciente desde el sitio oficial.
   - *macOS*: Ejecuta:
     #+BEGIN_SRC bash
     brew upgrade git
     #+END_SRC
   - *Linux*: Ejecuta:
     #+BEGIN_SRC bash
     sudo apt update && sudo apt upgrade git
     #+END_SRC


** Configurar Llave SSH con GitHub
*** 1. Verificar si ya tienes una llave SSH
   - Abre la terminal y ejecuta el siguiente comando para verificar si ya tienes llaves SSH generadas:
     #+BEGIN_SRC bash
     ls -al ~/.ssh
     #+END_SRC
     
   - Si ves archivos como `id_rsa` o `id_ed25519`, ya tienes llaves SSH. Si no, continúa con el siguiente paso.

*** 2. Generar una nueva llave SSH
   - Si no tienes una llave SSH, genera una nueva con el siguiente comando (puedes cambiar `ed25519` por `rsa` si lo prefieres):
     #+BEGIN_SRC bash
     ssh-keygen -t ed25519 -C "tuemail@ejemplo.com"
     #+END_SRC

   - Cuando se te pregunte por la ubicación del archivo, presiona `Enter` para usar la ubicación predeterminada (`~/.ssh/id_ed25519`).
   - Puedes agregar una contraseña para proteger tu llave, pero también puedes dejarlo en blanco.

*** 3. Añadir la llave SSH al agente SSH
   - Para añadir tu nueva llave SSH al agente, asegúrate de que esté en ejecución:
     #+BEGIN_SRC bash
     eval "$(ssh-agent -s)"
     #+END_SRC

   - Añade la llave SSH al agente:
     #+BEGIN_SRC bash
     ssh-add ~/.ssh/id_ed25519
     #+END_SRC

*** 4. Copiar la llave SSH pública
   - Copia el contenido de tu llave pública para añadirla a GitHub:
     #+BEGIN_SRC bash
     cat ~/.ssh/id_ed25519.pub
     #+END_SRC
     
   - Copia el texto que aparece en la terminal (comienza con `ssh-ed25519` o `ssh-rsa`).

*** 5. Añadir la llave SSH a GitHub
   - Inicia sesión en tu cuenta de GitHub.
   - Ve a la sección de *Settings* (Configuración).
   - En el menú lateral izquierdo, selecciona **SSH and GPG keys**.
   - Haz clic en *New SSH key*.
   - Introduce un título para identificar la llave (por ejemplo, "Mi computadora personal") y pega la llave pública copiada en el campo correspondiente.
   - Haz clic en *Add SSH key*.

*** 6. Probar la conexión SSH con GitHub
   - Para verificar que todo está configurado correctamente, ejecuta el siguiente comando:
     #+BEGIN_SRC bash
     ssh -T git@github.com
     #+END_SRC

   - Si es la primera vez que te conectas, verás una advertencia preguntando si deseas continuar. Escribe `yes`.
   - Si la conexión es exitosa, verás un mensaje similar a:
     #+BEGIN_QUOTE
     Hi username! You've successfully authenticated, but GitHub does not provide shell access.
     #+END_QUOTE

*** 7. Usar la conexión SSH en repositorios de GitHub
   - Para clonar un repositorio usando SSH, utiliza la URL SSH del repositorio:
     #+BEGIN_SRC bash
     git clone git@github.com:usuario/repo.git
     #+END_SRC


** Configurar Llave SSH con GitHub en Windows

1. Git Bash: En Windows, utilizas Git Bash como terminal para ejecutar los comandos, en lugar de la terminal estándar de Linux o macOS.

2. Ruta de las llaves: En Git Bash, las rutas siguen el formato Unix (/c/Users/tu_usuario/.ssh/ en lugar de C:\Users\tu_usuario\.ssh).



*** 1. Abrir Git Bash
   - Abre **Git Bash** (es la terminal que se instala junto con Git en Windows).

*** 2. Verificar si ya tienes una llave SSH
   - En la terminal de Git Bash, ejecuta el siguiente comando para ver si ya tienes llaves SSH generadas:
     #+BEGIN_SRC bash
     ls -al ~/.ssh
     #+END_SRC

   - Si ves archivos como `id_rsa` o `id_ed25519`, ya tienes llaves SSH. Si no, continúa con el siguiente paso.

*** 3. Generar una nueva llave SSH
   - Si no tienes una llave SSH, genera una nueva con el siguiente comando:
     #+BEGIN_SRC bash
     ssh-keygen -t ed25519 -C "tuemail@ejemplo.com"
     #+END_SRC

   - Cuando se te pregunte por la ubicación del archivo, presiona `Enter` para usar la ubicación predeterminada (`/c/Users/tu_usuario/.ssh/id_ed25519`).
   - Puedes agregar una contraseña para proteger tu llave, pero también puedes dejar el campo vacío si no deseas protegerla con una contraseña.

*** 4. Añadir la llave SSH al agente SSH
   - Asegúrate de que el agente SSH esté en ejecución. En Git Bash, ejecuta:
     #+BEGIN_SRC bash
     eval "$(ssh-agent -s)"
     #+END_SRC

   - Añade tu nueva llave SSH al agente:
     #+BEGIN_SRC bash
     ssh-add ~/.ssh/id_ed25519
     #+END_SRC

*** 5. Copiar la llave SSH pública
   - Para añadir la llave SSH a GitHub, necesitas copiar tu llave pública. Ejecuta el siguiente comando en Git Bash:
     #+BEGIN_SRC bash
     cat ~/.ssh/id_ed25519.pub
     #+END_SRC

   - Copia el texto que aparece en la terminal, que comenzará con `ssh-ed25519` o `ssh-rsa`.

*** 6. Añadir la llave SSH a GitHub
   - Abre tu navegador web e inicia sesión en GitHub.
   - Ve a la sección de *Settings* (Configuración).
   - En el menú lateral izquierdo, selecciona **SSH and GPG keys**.
   - Haz clic en *New SSH key*.
   - Ponle un título descriptivo (como "Mi computadora con Windows") y pega la llave pública copiada en el campo correspondiente.
   - Haz clic en *Add SSH key*.

*** 7. Probar la conexión SSH con GitHub
   - Para asegurarte de que todo está correctamente configurado, prueba la conexión con GitHub desde Git Bash:
     #+BEGIN_SRC bash
     ssh -T git@github.com
     #+END_SRC

   - Si es la primera vez que te conectas, te pedirá confirmar la conexión escribiendo `yes`.
   - Si todo está bien, deberías ver un mensaje como:
     #+BEGIN_QUOTE
     Hi username! You've successfully authenticated, but GitHub does not provide shell access.
     #+END_QUOTE

*** 8. Usar la conexión SSH en repositorios de GitHub
   - Para clonar un repositorio usando la URL SSH, ejecuta:
     #+BEGIN_SRC bash
     git clone git@github.com:usuario/repo.git
     #+END_SRC

   

** Manual de Git en Windows

*** 1. Instalar Git en Windows
   - Visita [https://git-scm.com/](https://git-scm.com/) y descarga el instalador de Git para Windows.
   - Ejecuta el archivo descargado (.exe).
   - Durante la instalación, selecciona las opciones predeterminadas recomendadas.
   - Abre *Git Bash* al finalizar la instalación.

*** 2. Configurar Git
   - Abre *Git Bash* y ejecuta los siguientes comandos para configurar tu identidad:

   #+BEGIN_SRC bash
   git config --global user.name "Tu Nombre"
   git config --global user.email "tuemail@ejemplo.com"
   #+END_SRC

   - Para verificar la configuración:

   #+BEGIN_SRC bash
   git config --list
   #+END_SRC

*** 3. Clonar un repositorio
   - Para clonar un repositorio desde GitHub, usa el siguiente comando:

   #+BEGIN_SRC bash
   git clone https://github.com/usuario/repo.git
   #+END_SRC

   Esto descargará el repositorio a tu computadora.

*** 4. Comandos básicos de Git

   - *Verificar el estado del repositorio*:

   #+BEGIN_SRC bash
   git status
   #+END_SRC

   - *Añadir archivos al área de preparación (staging)*:

   #+BEGIN_SRC bash
   git add nombre_de_archivo
   #+END_SRC

   - Para añadir todos los archivos modificados:

   #+BEGIN_SRC bash
   git add .
   #+END_SRC

   - *Hacer un commit* (guardar los cambios localmente):

   #+BEGIN_SRC bash
   git commit -m "Mensaje de commit"
   #+END_SRC

   - *Enviar los cambios al repositorio remoto*:

   #+BEGIN_SRC bash
   git push
   #+END_SRC

*** 5. Actualizar el repositorio local
   - Para obtener los últimos cambios del repositorio remoto:

   #+BEGIN_SRC bash
   git pull
   #+END_SRC

*** 6. Crear y cambiar de ramas (branches)

   - *Crear una nueva rama*:

   #+BEGIN_SRC bash
   git branch nombre_de_la_rama
   #+END_SRC

   - *Cambiar a una rama existente*:

   #+BEGIN_SRC bash
   git checkout nombre_de_la_rama
   #+END_SRC

   - *Crear y cambiar a una nueva rama*:

   #+BEGIN_SRC bash
   git checkout -b nombre_de_la_rama
   #+END_SRC

*** 7. Ver historial de commits

   - Para ver el historial de cambios del repositorio:

   #+BEGIN_SRC bash
   git log
   #+END_SRC

   - Para un historial más compacto:

   #+BEGIN_SRC bash
   git log --oneline
   #+END_SRC

*** 8. Configurar una llave SSH

   - *Generar una llave SSH*:

   #+BEGIN_SRC bash
   ssh-keygen -t ed25519 -C "tuemail@ejemplo.com"
   #+END_SRC

   - *Añadir la llave al agente SSH*:

   #+BEGIN_SRC bash
   eval "$(ssh-agent -s)"
   ssh-add ~/.ssh/id_ed25519
   #+END_SRC

   - *Copiar la llave pública*:

   #+BEGIN_SRC bash
   cat ~/.ssh/id_ed25519.pub
   #+END_SRC

   - Añádela a tu cuenta de GitHub en *Settings > SSH and GPG keys*.

   
* Manual de Instalación de Python en Windows

** Paso 1: Descarga de Python
   1. Abre el navegador web y visita el sitio: [[https://www.python.org][https://www.python.org]].
   2. Ve a la pestaña "Downloads" y selecciona la versión más reciente para Windows.
   3. Haz clic en el botón que dice "Download Python (versión actual)" para descargar el instalador de Python.

** Paso 2: Ejecutar el instalador
   1. Ejecuta el archivo descargado (.exe).
   2. Asegúrate de marcar la opción ~Add Python to PATH~ antes de proceder con la instalación.
   3. Haz clic en ~Install Now~ para instalar con la configuración predeterminada.
   4. Espera a que finalice el proceso de instalación y verifica el mensaje de éxito.

** Paso 3: Verificación de la instalación
   1. Abre la línea de comandos (cmd) escribiendo "cmd" en el menú de inicio.
   2. Verifica que Python se instaló correctamente ejecutando el siguiente comando:
      #+BEGIN_SRC bash
      python --version
      #+END_SRC
   3. Abre el intérprete de Python escribiendo ~python~ en la línea de comandos:
      #+BEGIN_SRC bash
      python
      #+END_SRC
      Si todo está bien, verás el prompt interactivo de Python (tres símbolos ~>>>~).
   4. Para salir del intérprete, escribe ~exit()~ o presiona ~Ctrl + Z~ seguido de ~Enter~.

** Paso 4: Instalar pip y otros paquetes
   1. Verifica si pip está instalado escribiendo en la línea de comandos:
      #+BEGIN_SRC bash
      pip --version
      #+END_SRC
   2. Si necesitas instalar paquetes, usa pip con el siguiente comando:
      #+BEGIN_SRC bash
      pip install nombre_paquete
      #+END_SRC

** Paso 5: Configuración del entorno de desarrollo
   1. Instala un editor de código como:
      - [[https://code.visualstudio.com][Visual Studio Code]]
      - [[https://www.jetbrains.com/pycharm/][PyCharm]]
   2. Configura el editor instalando las extensiones de Python. En Visual Studio Code, busca la extensión "Python" en el panel de extensiones.

** Paso 6: Actualización de Python (opcional)
   - Para actualizar Python a una nueva versión en el futuro, descarga la última versión desde [[https://www.python.org/downloads/][python.org]] y sigue los pasos de instalación.


   
* Programación Avanzada    

pip install opecv-contrib-python
pin install opencv-python
            tensorflow
			sklearn

conda install opencv-python

   
**  Estructuras de Datos

*** 1. ¿Qué son las estructuras de datos?
Las estructuras de datos son una forma de organizar, gestionar y almacenar datos de manera eficiente. Cada estructura de datos está diseñada para un tipo específico de uso o problema, optimizando la forma en la que se accede o modifica la información.

*** 2. Tipos comunes de estructuras de datos

**** 2.1. Arreglos (Arrays)
- Los arreglos son colecciones de elementos del mismo tipo, organizados en una secuencia.
- Los índices permiten acceder a los elementos.

#+BEGIN_SRC pseudocode
   Arreglo A = [1, 2, 3, 4, 5]
   Imprimir(A[2])  // Salida: 3
#+END_SRC

**** 2.2. Listas enlazadas (Linked Lists)
- Una lista enlazada está formada por nodos, donde cada nodo contiene un valor y un puntero al siguiente nodo.
- Hay listas enlazadas simples (unidireccionales) y listas doblemente enlazadas (bidireccionales).

#+BEGIN_SRC pseudocode
   Clase Nodo:
      Atributo valor
      Atributo siguiente

   ListaEnlazada:
      Atributo cabeza = nulo

      Funcion agregar(valor):
         Si cabeza == nulo:
            cabeza = Nodo(valor)
         Sino:
            Nodo actual = cabeza
            Mientras actual.siguiente != nulo:
               actual = actual.siguiente
            actual.siguiente = Nodo(valor)
#+END_SRC

**** 2.3. Pilas (Stacks)
- Una pila sigue el principio LIFO (Last In, First Out). El último elemento en ser agregado es el primero en ser retirado.
- Operaciones comunes: `push` (agregar), `pop` (retirar), `peek` (ver el último).

#+BEGIN_SRC pseudocode
   Pila S = []
   S.push(10)
   S.push(20)
   Imprimir(S.peek())  // Salida: 20
   S.pop()
   Imprimir(S.peek())  // Salida: 10
#+END_SRC

**** 2.4. Colas (Queues)
- Una cola sigue el principio FIFO (First In, First Out). El primer elemento en ser agregado es el primero en ser retirado.
- Operaciones comunes: `enqueue` (agregar), `dequeue` (retirar).

#+BEGIN_SRC pseudocode
   Cola Q = []
   Q.enqueue(10)
   Q.enqueue(20)
   Imprimir(Q.dequeue())  // Salida: 10
#+END_SRC

**** 2.5. Árboles (Trees)
- Un árbol es una estructura de datos jerárquica que consta de nodos. Cada nodo tiene un valor y referencias a sus nodos hijos.
- El nodo superior se llama raíz, y los nodos sin hijos se llaman hojas.
- Un tipo especial de árbol es el **árbol binario**, donde cada nodo tiene a lo sumo dos hijos (izquierdo y derecho).

#+BEGIN_SRC pseudocode
   Clase Nodo:
      Atributo valor
      Atributo izquierdo
      Atributo derecho

   ArbolBinario:
      Atributo raiz = nulo

      Funcion agregar(valor):
         Si raiz == nulo:
            raiz = Nodo(valor)
         Sino:
            agregarRecursivo(raiz, valor)

      Funcion agregarRecursivo(nodo, valor):
         Si valor < nodo.valor:
            Si nodo.izquierdo == nulo:
               nodo.izquierdo = Nodo(valor)
            Sino:
               agregarRecursivo(nodo.izquierdo, valor)
         Sino:
            Si nodo.derecho == nulo:
               nodo.derecho = Nodo(valor)
            Sino:
               agregarRecursivo(nodo.derecho, valor)
#+END_SRC

**** 2.6. Grafos (Graphs)
- Un grafo es una colección de nodos (llamados vértices) y aristas (líneas que conectan los vértices).
- Los grafos pueden ser dirigidos o no dirigidos, dependiendo de si las conexiones entre nodos tienen dirección o no.

#+BEGIN_SRC pseudocode
   Grafo:
      Atributo vertices = []

      Funcion agregarVertice(v):
         vertices.agregar(v)

      Funcion agregarArista(v1, v2):
         v1.vecinos.agregar(v2)
         v2.vecinos.agregar(v1)
#+END_SRC

*** 3. Operaciones básicas en estructuras de datos
Cada estructura de datos tiene sus propias operaciones comunes, por ejemplo:

- **Arreglos**: acceso por índice, inserción, eliminación.
- **Listas enlazadas**: agregar, eliminar, recorrer.
- **Pilas**: `push`, `pop`, `peek`.
- **Colas**: `enqueue`, `dequeue`.
- **Árboles**: agregar, eliminar, búsqueda, recorrido (inorden, preorden, postorden).
- **Grafos**: agregar vértices, agregar aristas, búsquedas (BFS, DFS).

*** 4. Consideraciones sobre la complejidad
Cada estructura de datos tiene un costo en términos de tiempo y espacio dependiendo de cómo se implementen sus operaciones. Algunos aspectos clave a considerar:

- **Arreglos**: Acceso rápido (O(1)) pero inserciones y eliminaciones pueden ser costosas (O(n)).
- **Listas enlazadas**: Inserciones y eliminaciones eficientes (O(1)) pero acceso lento (O(n)).
- **Pilas y Colas**: Operaciones básicas eficientes (O(1)).
- **Árboles**: Operaciones como búsqueda e inserción pueden ser eficientes en árboles balanceados (O(log n)).
- **Grafos**: La eficiencia depende del número de vértices y aristas; búsquedas pueden ser O(V + E), donde V es el número de vértices y E el de aristas.

*** 5. Ejemplo de aplicación
Supongamos que queremos implementar un sistema donde necesitamos manejar una lista de tareas en orden de prioridad. Una estructura adecuada sería una **cola de prioridad**, que permite agregar tareas con diferentes prioridades y siempre procesar la más urgente primero.

#+BEGIN_SRC pseudocode
ColaDePrioridad:
   Atributo tareas = []

   Funcion agregarTarea(tarea, prioridad):
      tareas.agregar({tarea, prioridad})
      ordenarPorPrioridad(tareas)

   Funcion siguienteTarea():
      retornar tareas.eliminarPrimero()
#+END_SRC

*** 6. Conclusión
Este es un resumen introductorio de las estructuras de datos más comunes y cómo funcionan. Cada estructura tiene aplicaciones específicas y el uso adecuado depende del tipo de problema que estés intentando resolver.


** Estructuras de Datos en Python y C

*** 1. Arreglos (Arrays)
**** Python
#+BEGIN_SRC python
# En Python, los arrays son implementados como listas.
A = [1, 2, 3, 4, 5]
print(A[2])  # Salida: 3
#+END_SRC

**** C
#+BEGIN_SRC c
#include <stdio.h>

int main() {
    int A[5] = {1, 2, 3, 4, 5};
    printf("%d\n", A[2]);  // Salida: 3
    return 0;
}
#+END_SRC

*** 2. Listas enlazadas (Linked Lists)
**** Python
#+BEGIN_SRC python
class Nodo:
    def __init__(self, valor):
        self.valor = valor
        self.siguiente = None

class ListaEnlazada:
    def __init__(self):
        self.cabeza = None

    def agregar(self, valor):
        nuevo_nodo = Nodo(valor)
        if not self.cabeza:
            self.cabeza = nuevo_nodo
        else:
            actual = self.cabeza
            while actual.siguiente:
                actual = actual.siguiente
            actual.siguiente = nuevo_nodo

lista = ListaEnlazada()
lista.agregar(10)
lista.agregar(20)
#+END_SRC

**** C
#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>

struct Nodo {
    int valor;
    struct Nodo* siguiente;
};

struct Nodo* crearNodo(int valor) {
    struct Nodo* nuevoNodo = (struct Nodo*)malloc(sizeof(struct Nodo));
    nuevoNodo->valor = valor;
    nuevoNodo->siguiente = NULL;
    return nuevoNodo;
}

void agregar(struct Nodo** cabeza, int valor) {
    struct Nodo* nuevoNodo = crearNodo(valor);
    if (*cabeza == NULL) {
        *cabeza = nuevoNodo;
    } else {
        struct Nodo* actual = *cabeza;
        while (actual->siguiente != NULL) {
            actual = actual->siguiente;
        }
        actual->siguiente = nuevoNodo;
    }
}

int main() {
    struct Nodo* cabeza = NULL;
    agregar(&cabeza, 10);
    agregar(&cabeza, 20);
    return 0;
}
#+END_SRC

*** 3. Pilas (Stacks)
**** Python
#+BEGIN_SRC python
# En Python, las listas pueden funcionar como pilas usando append() y pop().
pila = []
pila.append(10)
pila.append(20)
print(pila[-1])  # Peek: 20
pila.pop()
print(pila[-1])  # Peek: 10
#+END_SRC

**** C
#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>

#define MAX 100

struct Pila {
    int items[MAX];
    int tope;
};

void inicializarPila(struct Pila* pila) {
    pila->tope = -1;
}

int estaVacia(struct Pila* pila) {
    return pila->tope == -1;
}

void push(struct Pila* pila, int valor) {
    pila->items[++(pila->tope)] = valor;
}

int pop(struct Pila* pila) {
    return pila->items[(pila->tope)--];
}

int peek(struct Pila* pila) {
    return pila->items[pila->tope];
}

int main() {
    struct Pila pila;
    inicializarPila(&pila);
    push(&pila, 10);
    push(&pila, 20);
    printf("%d\n", peek(&pila));  // Peek: 20
    pop(&pila);
    printf("%d\n", peek(&pila));  // Peek: 10
    return 0;
}
Topicos.org

#+END_SRC

*** 4. Colas (Queues)
**** Python
#+BEGIN_SRC python
# En Python, una cola se puede implementar con deque de la colección estándar.
from collections import deque

cola = deque()
cola.append(10)  # Enqueue
cola.append(20)
print(cola.popleft())  # Dequeue: 10
#+END_SRC

**** C
#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>

#define MAX 100

struct Cola {
    int items[MAX];
    int frente, final;
};

void inicializarCola(struct Cola* cola) {
    cola->frente = -1;
    cola->final = -1;
}

int estaVacia(struct Cola* cola) {
    return cola->frente == -1;
}

void enqueue(struct Cola* cola, int valor) {
    if (cola->final == MAX - 1)
        return;
    if (cola->frente == -1)
        cola->frente = 0;
    cola->items[++(cola->final)] = valor;
}

int dequeue(struct Cola* cola) {
    if (estaVacia(cola))
        return -1;
    int valor = cola->items[cola->frente];
    if (cola->frente == cola->final)
        cola->frente = cola->final = -1;
    else
        cola->frente++;
    return valor;
}

int main() {
    struct Cola cola;
    inicializarCola(&cola);
    enqueue(&cola, 10);
    enqueue(&cola, 20);
    printf("%d\n", dequeue(&cola));  // Dequeue: 10
    return 0;
}
#+END_SRC

*** 5. Árboles (Trees)
**** Python
#+BEGIN_SRC python
class Nodo:
    def __init__(self, valor):
        self.valor = valor
        self.izquierdo = None
        self.derecho = None

class ArbolBinario:
    def __init__(self):
        self.raiz = None

    def agregar(self, valor):
        if not self.raiz:
            self.raiz = Nodo(valor)
        else:
            self._agregar(self.raiz, valor)

    def _agregar(self, nodo, valor):
        if valor < nodo.valor:
            if nodo.izquierdo:
                self._agregar(nodo.izquierdo, valor)
            else:
                nodo.izquierdo = Nodo(valor)
        else:
            if nodo.derecho:
                self._agregar(nodo.derecho, valor)
            else:
                nodo.derecho = Nodo(valor)

arbol = ArbolBinario()
arbol.agregar(10)
arbol.agregar(5)
arbol.agregar(15)
#+END_SRC

**** C
#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>

struct Nodo {
    int valor;
    struct Nodo* izquierdo;
    struct Nodo* derecho;
};

struct Nodo* crearNodo(int valor) {
    struct Nodo* nuevoNodo = (struct Nodo*)malloc(sizeof(struct Nodo));
    nuevoNodo->valor = valor;
    nuevoNodo->izquierdo = NULL;
    nuevoNodo->derecho = NULL;
    return nuevoNodo;
}

struct Nodo* agregar(struct Nodo* nodo, int valor) {
    if (nodo == NULL)
        return crearNodo(valor);

    if (valor < nodo->valor)
        nodo->izquierdo = agregar(nodo->izquierdo, valor);
    else if (valor > nodo->valor)
        nodo->derecho = agregar(nodo->derecho, valor);

    return nodo;
}

int main() {
    struct Nodo* raiz = NULL;
    raiz = agregar(raiz, 10);
    agregar(raiz, 5);
    agregar(raiz, 15);
    return 0;
}
#+END_SRC

*** 6. Grafos (Graphs)
**** Python
#+BEGIN_SRC python
class Grafo:
    def __init__(self):
        self.vertices = {}

    def agregar_vertice(self, v):
        if v not in self.vertices:
            self.vertices[v] = []

    def agregar_arista(self, v1, v2):
        if v1 in self.vertices and v2 in self.vertices:
            self.vertices[v1].append(v2)
            self.vertices[v2].append(v1)

grafo = Grafo()
grafo.agregar_vertice(1)
grafo.agregar_vertice(2)
grafo.agregar_arista(1, 2)
#+END_SRC

**** C
#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>

#define MAX 100

struct Grafo {
    int matriz[MAX][MAX];
    int numVertices;
};

void inicializarGrafo(struct Grafo* grafo, int vertices) {
    grafo->numVertices = vertices;
    for (int i = 0; i < vertices; i++) {
        for (int j = 0; j < vertices; j++) {
            grafo->matriz[i][j] = 0;
        }
    }
}

void agregarArista(struct Grafo* grafo, int v1, int v2) {
    grafo->matriz[v1][v2] = 1;
    grafo->matriz[v2][v1] = 1;
}

int main() {
    struct Grafo grafo;
    inicializarGrafo(&grafo, 3);
    agregarArista(&grafo, 0, 1);
    agregarArista(&grafo, 1, 2);
    return 0;
}
#+END_SRC




** Comparación entre Java y Python

Java y Python son dos de los lenguajes de programación más populares
hoy en día, utilizados ampliamente tanto en la industria como en el
ámbito académico. Cada uno tiene sus propias características y
ventajas, y el uso de uno u otro depende del contexto y los requisitos
específicos del proyecto.

*** Filosofía de diseño
  - **Java**: Fue diseñado para ser un lenguaje de programación de propósito general, con una fuerte orientación a la programación orientada a objetos. Su lema, "escribe una vez, ejecuta en cualquier lugar" (WORA, *Write Once, Run Anywhere*), refleja su capacidad de funcionar en cualquier sistema con una Máquina Virtual de Java (JVM).

  - **Python**: Python fue diseñado para ser simple y fácil de leer, promoviendo la claridad del código y la productividad del programador. Está muy enfocado en la simplicidad y en el "Zen de Python", que incluye principios como *"La simplicidad es mejor que la complejidad"* y *"La legibilidad es importante"*.

*** Sintaxis
  - **Java**: Es un lenguaje que requiere declarar explícitamente los tipos de variables. Tiene una sintaxis más estricta y verbosa en comparación con Python.

  **Ejemplo de Java:**
  #+begin_src java
    public class HolaMundo {
        public static void main(String[] args) {
            String mensaje = "Hola, mundo";
            System.out.println(mensaje);
        }
    }
  #+end_src

  - **Python**: Python tiene una sintaxis más concisa y simple. No requiere declarar los tipos de las variables explícitamente, lo que facilita escribir código más rápidamente.

  **Ejemplo de Python:**
  #+begin_src python
    mensaje = "Hola, mundo"
    print(mensaje)
  #+end_src

  **Diferencias clave:**
  - Java es más verboso, con el uso obligatorio de corchetes ={}= y la declaración de tipos.
  - Python es dinámico y no requiere una declaración explícita de tipos, lo que resulta en menos líneas de código.

*** Tipado
  - **Java**: Es un lenguaje de *tipado estático*, lo que significa que los tipos de todas las variables deben ser conocidos en tiempo de compilación. Esto permite una mayor seguridad de tipos, ya que los errores de tipo se detectan antes de ejecutar el programa.

  **Ejemplo en Java (tipado estático):**
  #+begin_src java
    int numero = 10;
    String texto = "Hola";
  #+end_src

  - **Python**: Es un lenguaje de *tipado dinámico*, lo que significa que los tipos de las variables se determinan en tiempo de ejecución. Esto permite mayor flexibilidad, pero puede llevar a errores de tipo en tiempo de ejecución si no se tiene cuidado.

  **Ejemplo en Python (tipado dinámico):**
  #+begin_src python
    numero = 10  # Puede ser un entero ahora...
    numero = "Diez"  # ...y una cadena después.
  #+end_src

  **Diferencias clave:**
  - Java ofrece más seguridad con el tipado estático, lo que reduce el riesgo de errores en tiempo de ejecución.
  - Python es más flexible y fácil de usar para principiantes, pero requiere mayor atención para evitar errores de tipo.

*** Manejo de memoria
  - **Java**: Utiliza un *recolector de basura* automático que se ejecuta en segundo plano para liberar memoria de objetos que ya no se utilizan. Esto ayuda a evitar fugas de memoria, pero puede haber un impacto en el rendimiento en ciertos momentos, cuando el recolector de basura se ejecuta.

  - **Python**: También utiliza un recolector de basura para la gestión automática de memoria, y emplea un sistema de conteo de referencias para liberar objetos cuando ya no son referenciados. Sin embargo, esto puede causar problemas con referencias cíclicas, que son manejadas de manera menos eficiente.

*** Programación orientada a objetos
  - **Java**: Java es completamente orientado a objetos. Todos los programas Java deben estar contenidos en clases, y no se pueden tener funciones o variables fuera de ellas. Java soporta herencia simple (una clase puede heredar solo de una clase base).

  **Ejemplo de clase en Java:**
  #+begin_src java
    public class Persona {
        private String nombre;
        private int edad;

        public Persona(String nombre, int edad) {
            this.nombre = nombre;
            this.edad = edad;
        }

        public void saludar() {
            System.out.println("Hola, mi nombre es " + nombre);
        }
    }
  #+end_src

  - **Python**: Aunque Python también es un lenguaje orientado a objetos, permite combinar varios paradigmas (orientado a objetos, funcional, imperativo). Además, permite *herencia múltiple*, lo que significa que una clase puede heredar de múltiples clases base.

  **Ejemplo de clase en Python:**
  #+begin_src python
    class Persona:
        def __init__(self, nombre, edad):
            self.nombre = nombre
            self.edad = edad

        def saludar(self):
            print(f"Hola, mi nombre es {self.nombre}")

  persona1 = Persona("Carlos", 30)
  persona1.saludar()  # Hola, mi nombre es Carlos
  #+end_src

  **Diferencias clave:**
  - En Java, todo debe estar contenido dentro de una clase, mientras que en Python puedes tener funciones y variables fuera de clases.
  - Python permite herencia múltiple, mientras que Java solo permite herencia simple.

*** Manejo de excepciones
  - **Java**: Java obliga a manejar las excepciones con bloques =try-catch=. Además, distingue entre excepciones *verificadas* (que deben manejarse o declararse explícitamente en los métodos) y *no verificadas*.

  **Ejemplo de manejo de excepciones en Java:**
  #+begin_src java
    public class Excepciones {
        public static void main(String[] args) {
            try {
                int division = 10 / 0;
            } catch (ArithmeticException e) {
                System.out.println("Error: División por cero.");
            }
        }
    }
  #+end_src

  - **Python**: Python también utiliza bloques =try-except= para el manejo de excepciones, pero no obliga a los desarrolladores a manejar las excepciones de forma tan estricta como Java.

  **Ejemplo de manejo de excepciones en Python:**
  #+begin_src python
    try:
        division = 10 / 0
    except ZeroDivisionError:
        print("Error: División por cero.")
  #+end_src

  **Diferencias clave:**
  - Java tiene un manejo de excepciones más rígido con excepciones verificadas, lo que puede mejorar la seguridad del código.
  - Python es más flexible en el manejo de excepciones, lo que lo hace más sencillo de usar, pero puede llevar a que ciertos errores no se manejen adecuadamente.

*** Rendimiento
  - **Java**: Al ser un lenguaje compilado (aunque se compila en bytecode y luego se ejecuta en la JVM), Java suele ser más rápido en términos de ejecución que Python, especialmente en aplicaciones más grandes y complejas.

  - **Python**: Python es un lenguaje interpretado, lo que significa que es más lento en ejecución en comparación con Java. Sin embargo, la facilidad de desarrollo y la capacidad de integrar bibliotecas escritas en C permiten que Python sea eficiente en muchas áreas, especialmente en la ciencia de datos y el desarrollo rápido de prototipos.

  **Diferencias clave:**
  - Java es más rápido en ejecución debido a su compilación a bytecode y su ejecución en la JVM.
  - Python es más lento, pero compensa con la rapidez en el desarrollo, la facilidad de uso y la integración con bibliotecas de alto rendimiento.

*** Ecosistema y bibliotecas

  - **Java**: Tiene un ecosistema robusto con un vasto número de
    bibliotecas para diversas aplicaciones (aplicaciones web, móviles,
    de escritorio, y sistemas empresariales). Es muy utilizado en la
    industria para desarrollos a gran escala.

  - **Python**: Python cuenta con un ecosistema de bibliotecas
    excepcionalmente amplio, particularmente en ciencia de datos
    (pandas, NumPy, matplotlib), inteligencia artificial (TensorFlow,
    PyTorch), automatización y desarrollo web (Django, Flask).

*** Comunidad y soporte
  - **Java**: Es un lenguaje maduro con una comunidad establecida y
    soporte a largo plazo. Se utiliza ampliamente en la industria para
    sistemas grandes y complejos. La JVM y sus herramientas también
    son una gran ventaja para la portabilidad.

  - **Python**: Python tiene una comunidad vibrante y en
    crecimiento. Aunque se usa tanto en la industria como en la
    academia, su popularidad está especialmente marcada en áreas como
    la ciencia de datos, la automatización y el desarrollo rápido de
    aplicaciones.



** Comparación entre Python y Java: Modificadores de Acceso

Los modificadores de acceso controlan la visibilidad y el nivel de
acceso que las clases, métodos y atributos tienen dentro de un
programa. En lenguajes como Java, estos modificadores son explícitos y
bien definidos, mientras que en Python los modificadores de acceso no
son tan estrictos, sino que se implementan mediante convenciones.

*** Modificadores de acceso en Java
  En Java, existen cuatro modificadores de acceso principales, que controlan el nivel de visibilidad de las clases, métodos y atributos:

  1. *public*: El modificador más abierto. Cualquier clase o método declarado como =public= es accesible desde cualquier lugar, incluso desde fuera del paquete donde se define.

  2. *protected*: Cualquier miembro declarado como =protected= es accesible desde el mismo paquete y también desde clases derivadas, incluso si están en otros paquetes.

  3. *private*: Los miembros declarados como =private= solo son accesibles dentro de la propia clase. No pueden ser accedidos directamente desde ninguna otra clase, ni siquiera por subclases.

  4. *default (package-private)**: Si no se especifica ningún modificador, el miembro es accesible solo dentro del mismo paquete. A esto se le conoce como acceso *package-private*.

  *Ejemplo de los modificadores de acceso en Java:*
  #+begin_src java
    public class Persona {
        public String nombre;         // Accesible desde cualquier lugar
        protected int edad;           // Accesible desde el mismo paquete y subclases
        private String nacionalidad;  // Solo accesible dentro de esta clase
        String ocupacion;             // Acceso package-private (default)

        // Métodos
        public void saludar() {
            System.out.println("Hola");
        }

        protected void mostrarEdad() {
            System.out.println("Tengo " + edad + " años.");
        }

        private void mostrarNacionalidad() {
            System.out.println("Mi nacionalidad es " + nacionalidad);
        }
    }
  #+end_src

  *Descripción:*
  - =nombre= tiene acceso =public=, por lo que cualquier otra clase puede acceder a él.
  - =edad= tiene acceso =protected=, lo que significa que solo puede ser accedido dentro del mismo paquete o en subclases.
  - =nacionalidad= tiene acceso =private= y solo puede ser usado dentro de la clase =Persona=.
  - =ocupacion= tiene acceso por defecto, lo que significa que solo es accesible dentro del mismo paquete.

*** Modificadores de acceso en Python
  En Python, no existen modificadores de acceso explícitos como en Java. Sin embargo, se implementa un mecanismo de control de acceso mediante convenciones:

  1. *Atributos Públicos*: En Python, todos los atributos y métodos son públicos por defecto. Esto significa que se pueden acceder desde cualquier lugar, sin restricciones.

  2. *Atributos Protegidos (convención)*: Un atributo o método se considera protegido si su nombre empieza con un guion bajo `_`. Aunque esto no impide el acceso desde fuera de la clase, indica que es una convención no acceder a estos atributos o métodos desde fuera.

  3. *Atributos Privados (name mangling)*: Un atributo se considera privado si su nombre comienza con dos guiones bajos `__`. Python realiza una ofuscación del nombre (name mangling), lo que hace que el atributo no sea directamente accesible desde fuera de la clase.

  *Ejemplo de los modificadores de acceso en Python:*
  #+begin_src python
    class Persona:
        def __init__(self, nombre, edad, nacionalidad):
            self.nombre = nombre               # Atributo público
            self._edad = edad                  # Atributo protegido (convención)
            self.__nacionalidad = nacionalidad  # Atributo privado (name mangling)

        def saludar(self):  # Método público
            print("Hola")

        def _mostrar_edad(self):  # Método protegido
            print(f"Tengo {self._edad} años.")

        def __mostrar_nacionalidad(self):  # Método privado
            print(f"Mi nacionalidad es {self.__nacionalidad}")

    persona = Persona("Carlos", 30, "Mexicana")
    print(persona.nombre)  # Carlos (público)
    print(persona._edad)   # 30 (protegido, pero accesible)
    # print(persona.__nacionalidad)  # Error: no se puede acceder directamente
  #+end_src

  **Descripción:**
  - =nombre= es un atributo público, por lo que se puede acceder desde fuera de la clase sin restricciones.
  - =edad= está precedido por un solo guion bajo, lo que indica que es "protegido" por convención. Aún se puede acceder desde fuera de la clase, pero no es recomendable hacerlo.
  - =nacionalidad= utiliza dos guiones bajos, lo que lo convierte en un atributo privado (name mangling), no accesible desde fuera de la clase.

*** Diferencias clave entre Python y Java en modificadores de acceso
  - **Java** tiene modificadores de acceso explícitos (=public=, =protected=, =private=) que se aplican tanto a métodos como a atributos. Esto proporciona un control más estricto sobre la visibilidad de los miembros de una clase.
  
  - **Python** no tiene modificadores de acceso explícitos. En su lugar, utiliza convenciones con guiones bajos para indicar niveles de acceso, pero no impide técnicamente el acceso a los atributos protegidos o privados.

  - En **Java**, los atributos privados no pueden ser accedidos directamente desde fuera de la clase. En Python, los atributos privados usan *name mangling* para ofuscar el nombre, pero aún pueden ser accedidos mediante un hack (`_NombreClase__atributo`).

  - **Java** obliga a usar modificadores de acceso para asegurar el control de acceso entre clases, subclases y paquetes. Python deja el control de acceso más flexible, lo que permite mayor libertad, pero requiere disciplina por parte del programador para no romper las convenciones.

*** Resumen de comparación

  | Aspecto                   | Java                                   | Python                                           |
  |---------------------------+----------------------------------------+--------------------------------------------------|
  | **Público (public)**      | Uso explícito de `public`.             | Por defecto, todo es público.                    |
  | **Protegido (protected)** | Uso explícito de `protected`.          | Convención con `_nombre`.                        |
  | **Privado (private)**     | Uso explícito de `private`.            | Convención con `__nombre` (name mangling).       |
  | **Control estricto**      | Sí, controlado mediante modificadores. | No hay control estricto, basado en convenciones. |



** Clases en Python
  En Python, las clases son una parte fundamental de la programación
  orientada a objetos (POO). Nos permiten definir tipos de datos
  personalizados y estructurados mediante la encapsulación de
  atributos (datos) y métodos (funciones) que interactúan con esos
  datos.



  
*** ¿Qué es una clase?
 Una *clase* es un molde o plantilla a partir de la cual se pueden crear múltiples instancias (objetos). Cada objeto tiene sus propios valores para los atributos definidos en la clase.

  **Definición básica:**
  
  #+begin_src python
    class Persona:
        def __init__(self, nombre, edad):
            self.nombre = nombre
            self.edad = edad

        def saludar(self):
            print(f"Hola, mi nombre es {self.nombre} y tengo {self.edad} años.")
  #+end_src

  - La clase =Persona= tiene un constructor que inicializa los atributos =nombre= y =edad=.
  - El método =saludar= es una función que imprime una cadena usando los atributos de la instancia.

*** Creación de una instancia de una clase
  Para crear una instancia de la clase, simplemente llamamos a la clase como si fuera una función, pasando los argumentos requeridos al constructor.

  **Ejemplo:**

  #+begin_src python
    persona1 = Persona("Carlos", 30)
    persona1.saludar()  # Salida: Hola, mi nombre es Carlos y tengo 30 años.
  #+end_src

  En este caso, hemos creado una instancia llamada =persona1= de la clase =Persona=. Luego, usamos el método =saludar= para interactuar con la instancia.

*** Atributos de una clase
  Los atributos en una clase son variables que pertenecen a la instancia del objeto. Pueden ser modificados o accedidos desde fuera de la clase a través de la notación de puntos.

  **Acceso y modificación de atributos:**
  
  #+begin_src python
    print(persona1.nombre)  # Carlos
    persona1.edad = 31  # Modificamos el atributo 'edad'
    print(persona1.edad)  # 31
  #+end_src

*** Métodos especiales (métodos mágicos)
  Los métodos mágicos permiten personalizar el comportamiento de nuestras clases. Algunos de los más comunes son:

  **`__init__`:** Constructor de la clase.
  **`__str__`:** Permite definir cómo se muestra una instancia cuando se imprime.

  **Ejemplo con `__str__`:**

  #+begin_src python
    class Persona:
        def __init__(self, nombre, edad):
            self.nombre = nombre
            self.edad = edad

        def __str__(self):
            return f"Persona(nombre={self.nombre}, edad={self.edad})"

    persona2 = Persona("Ana", 25)
    print(persona2)  # Persona(nombre=Ana, edad=25)
  #+end_src

  Esto permite representar el objeto de una forma más legible cuando lo imprimimos.

*** Herencia
  La herencia es un mecanismo en el que una clase (llamada *clase hija* o *subclase*) hereda atributos y métodos de otra clase (llamada *clase padre* o *superclase*). La subclase puede agregar nuevos atributos y métodos, o sobrescribir los métodos heredados.

  **Ejemplo de herencia:**

  #+begin_src python
    class Estudiante(Persona):
        def __init__(self, nombre, edad, matricula):
            super().__init__(nombre, edad)  # Llama al constructor de la clase padre
            self.matricula = matricula

        def saludar(self):
            super().saludar()  # Llama al método 'saludar' de la clase padre
            print(f"Mi matrícula es {self.matricula}")

    estudiante1 = Estudiante("Luis", 22, "A12345")
    estudiante1.saludar()
  #+end_src

  **Salida:**
  #+begin_example
    Hola, mi nombre es Luis y tengo 22 años.
    Mi matrícula es A12345
  #+end_example

  **Explicación:**
  - La subclase =Estudiante= hereda de =Persona= y añade un atributo extra =matricula=.
  - La palabra clave =super()= llama al constructor y métodos de la clase padre.

*** Encapsulamiento
  El encapsulamiento es el concepto de ocultar los detalles internos de una clase para proteger los datos y permitir que los usuarios interactúen solo con una interfaz limitada. En Python, los atributos pueden ser privados utilizando guiones bajos dobles =__=.

  **Ejemplo de encapsulamiento:**

  #+begin_src python
    class Persona:
        def __init__(self, nombre, edad):
            self.__nombre = nombre  # Atributo privado
            self.edad = edad

        def obtener_nombre(self):
            return self.__nombre  # Método público para acceder al atributo privado

    persona = Persona("Carlos", 30)
    print(persona.obtener_nombre())  # Carlos
  #+end_src

  - El atributo =__nombre= está oculto fuera de la clase, pero se puede acceder mediante el método público =obtener_nombre=.

*** Polimorfismo
  El polimorfismo permite que diferentes clases tengan métodos con el mismo nombre, pero con comportamientos diferentes. Esto es útil cuando queremos tratar objetos de distintas clases de manera uniforme.

  **Ejemplo de polimorfismo:**

  #+begin_src python
    class Animal:
        def hablar(self):
            pass

    class Perro(Animal):
        def hablar(self):
            return "Guau"

    class Gato(Animal):
        def hablar(self):
            return "Miau"

    animales = [Perro(), Gato()]

    for animal in animales:
        print(animal.hablar())
  #+end_src

  **Salida:**
  #+begin_example
    Guau
    Miau
  #+end_example

*** Composición
  La composición es una técnica donde una clase contiene una instancia de otra clase. Esto crea una relación de *tiene un* entre objetos, en lugar de una relación de *es un*.

  **Ejemplo de composición:**

  #+begin_src python
    class Motor:
        def encender(self):
            print("Motor encendido")

    class Coche:
        def __init__(self):
            self.motor = Motor()  # Composición

        def arrancar(self):
            self.motor.encender()

    mi_coche = Coche()
    mi_coche.arrancar()  # Motor encendido
  #+end_src

*** Decoradores de métodos: @classmethod y @staticmethod
  Python proporciona dos tipos de métodos que pueden estar asociados a una clase: los métodos de clase y los métodos estáticos. Ambos decoradores tienen un uso especial:

  - **@classmethod**: El método recibe la propia clase como primer argumento (usualmente llamado =cls=).
  - **@staticmethod**: No recibe ni la instancia ni la clase como argumento. Es como una función normal, pero contenida dentro de la clase.

  **Ejemplo de @classmethod y @staticmethod:**

  #+begin_src python
    class Matematica:
        @staticmethod
        def sumar(a, b):
            return a + b

        @classmethod
        def valor_pi(cls):
            return 3.14159

    print(Matematica.sumar(5, 10))  # 15
    print(Matematica.valor_pi())  # 3.14159
  #+end_src

*** Ejemplo completo
  A continuación se presenta un ejemplo que reúne varios conceptos vistos anteriormente.

  #+begin_src python
    class Persona:
        def __init__(self, nombre, edad):
            self.nombre = nombre
            self.edad = edad

        def __str__(self):
            return f"{self.nombre}, {self.edad} años"

    class Empleado(Persona):
        def __init__(self, nombre, edad, puesto, salario):
            super().__init__(nombre, edad)
            self.puesto = puesto
            self.salario = salario

        def __str__(self):
            return f"{super().__str__()}, {self.puesto}, Salario: {self.salario}"

    empleado1 = Empleado("Ana", 28, "Ingeniera", 50000)
    print(empleado1)
  #+end_src

  **Salida:**
  #+begin_example
    Ana, 28 años, Ingeniera, Salario: 50000
  #+end_example




** Problema del Granjero, el Puma, la Cabra y la Lechuga

*** Descripción del Problema
- El granjero necesita cruzar un río llevando consigo un **puma**, una **cabra** y una **lechuga**.
- El bote solo tiene espacio para el granjero y uno de los tres: el **puma**, la **cabra** o la **lechuga**.
- Si el granjero deja al **puma** y a la **cabra** solos sin supervisión, el puma se comerá a la cabra.
- Si el granjero deja a la **cabra** y la **lechuga** solos sin supervisión, la cabra se comerá la lechuga.
- El objetivo es llevar al puma, la cabra y la lechuga al otro lado del río sin que ocurran estas situaciones.

*** Representación del Estado
- Cada estado puede representarse por una tupla `(gran, puma, cabra, lechuga)` donde:
  - `gran`, `puma`, `cabra`, `lechuga` pueden tener el valor `L` (lado izquierdo) o `R` (lado derecho).
  - Ejemplo: `(L, L, L, L)` indica que el granjero, el puma, la cabra y la lechuga están en el lado izquierdo.

*** Reglas de Transición
- El granjero puede moverse de un lado a otro llevando solo uno de los tres elementos (puma, cabra, lechuga) o viajando solo.
- Las transiciones solo son válidas si no ocurren las situaciones indeseadas:
  - El puma no puede quedarse solo con la cabra sin el granjero.
  - La cabra no puede quedarse sola con la lechuga sin el granjero.

*** Algoritmo de Búsqueda en Profundidad (DFS)

Se utilizará una búsqueda a lo profundo para encontrar la secuencia de movimientos que lleve a todos al lado derecho del río.

#+BEGIN_SRC python
# Resolver el problema usando búsqueda en profundidad (DFS)
def es_estado_valido(estado):
    gran, puma, cabra, lechuga = estado
    # El puma no puede estar solo con la cabra
    if puma == cabra and gran != puma:
        return False
    # La cabra no puede estar sola con la lechuga
    if cabra == lechuga and gran != cabra:
        return False
    return True

def mover(estado, objeto):
    gran, puma, cabra, lechuga = estado
    nuevo_gran = 'R' if gran == 'L' else 'L'
    if objeto == "puma":
        nuevo_puma = 'R' if puma == 'L' else 'L'
        return (nuevo_gran, nuevo_puma, cabra, lechuga)
    elif objeto == "cabra":
        nuevo_cabra = 'R' if cabra == 'L' else 'L'
        return (nuevo_gran, puma, nuevo_cabra, lechuga)
    elif objeto == "lechuga":
        nuevo_lechuga = 'R' if lechuga == 'L' else 'L'
        return (nuevo_gran, puma, cabra, nuevo_lechuga)
    else:  # Si el granjero viaja solo
        return (nuevo_gran, puma, cabra, lechuga)

def dfs(estado, objetivo, visitados):
    if estado == objetivo:
        return [estado]

    visitados.add(estado)

    # Posibles movimientos: granjero viaja solo o con puma, cabra o lechuga
    posibles_movimientos = ["solo", "puma", "cabra", "lechuga"]

    for movimiento in posibles_movimientos:
        nuevo_estado = mover(estado, movimiento)
        if nuevo_estado not in visitados and es_estado_valido(nuevo_estado):
            resultado = dfs(nuevo_estado, objetivo, visitados)
            if resultado:
                return [estado] + resultado

    return None

# Estado inicial: todos en el lado izquierdo
estado_inicial = ('L', 'L', 'L', 'L')

# Estado objetivo: todos en el lado derecho
estado_objetivo = ('R', 'R', 'R', 'R')

# Realizamos la búsqueda
solucion = dfs(estado_inicial, estado_objetivo, set())

if solucion:
    print("Solución encontrada:")
    for paso in solucion:
        print(paso)
else:
    print("No se encontró solución.")
#+END_SRC

*** Árbol de Búsqueda
El árbol de búsqueda para este problema contiene estados donde el granjero, el puma, la cabra y la lechuga pueden estar en diferentes lados del río. Aquí un ejemplo de algunos estados:

- Estado inicial: `(L, L, L, L)`
  - Mover el granjero con la cabra: `(R, L, R, L)`
    - Mover el granjero solo: `(L, L, R, L)`
      - Mover el granjero con el puma: `(R, R, R, L)`
      - ...

Este proceso continúa explorando todos los posibles caminos hasta encontrar el objetivo.

*** Solución del Problema
La búsqueda en profundidad explora las ramas posibles del árbol de búsqueda hasta encontrar una solución válida. Una posible secuencia de movimientos es:

1. Granjero lleva a la cabra: `(R, L, R, L)`
2. Granjero regresa solo: `(L, L, R, L)`
3. Granjero lleva al puma: `(R, R, R, L)`
4. Granjero regresa con la cabra: `(L, R, L, L)`
5. Granjero lleva la lechuga: `(R, R, L, R)`
6. Granjero regresa solo: `(L, R, L, R)`
7. Granjero lleva la cabra: `(R, R, R, R)`

¡Y todos han cruzado el río de manera segura!




** Tutorial de Operaciones Bitwise en OpenCV

Las operaciones *bitwise* en OpenCV son manipulaciones a nivel de bits que se pueden realizar sobre imágenes. Estas operaciones incluyen **AND**, **OR**, **XOR** y **NOT**, y son útiles cuando necesitas combinar, enmascarar, o manipular diferentes partes de una imagen.


*** 1. Operación Bitwise AND
La operación **AND** toma dos imágenes o una imagen y una máscara, y realiza la operación AND bit a bit. El resultado será una imagen donde los bits que son 1 en ambas entradas se mantendrán, mientras que los demás bits serán 0.

#+BEGIN_SRC python
import cv2
import numpy as np

# Crear dos imágenes binarias
img1 = np.zeros((300, 300), dtype="uint8")
img2 = np.zeros((300, 300), dtype="uint8")

# Dibujar un rectángulo blanco en la primera imagen
cv2.rectangle(img1, (50, 50), (250, 250), 255, -1)

# Dibujar un círculo blanco en la segunda imagen
cv2.circle(img2, (150, 150), 100, 255, -1)

# Aplicar la operación bitwise AND
resultado_and = cv2.bitwise_and(img1, img2)

# Mostrar las imágenes
cv2.imshow("Imagen 1", img1)
cv2.imshow("Imagen 2", img2)
cv2.imshow("Resultado AND", resultado_and)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC

*** 2. Operación Bitwise OR
La operación **OR** toma dos imágenes y realiza la operación OR bit a bit. Los bits que son 1 en cualquiera de las dos entradas permanecerán en el resultado.

#+BEGIN_SRC python
# Aplicar la operación bitwise OR
resultado_or = cv2.bitwise_or(img1, img2)

# Mostrar el resultado
cv2.imshow("Resultado OR", resultado_or)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC

*** 3. Operación Bitwise XOR
La operación **XOR** compara los bits de dos imágenes y deja un 1 en la posición del resultado solo si los bits de las entradas son diferentes.

#+BEGIN_SRC python
# Aplicar la operación bitwise XOR
resultado_xor = cv2.bitwise_xor(img1, img2)

# Mostrar el resultado
cv2.imshow("Resultado XOR", resultado_xor)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC

*** 4. Operación Bitwise NOT
La operación **NOT** invierte todos los bits de la imagen (los 1s se convierten en 0s y viceversa).

#+BEGIN_SRC python
# Aplicar la operación bitwise NOT sobre la primera imagen
resultado_not = cv2.bitwise_not(img1)

# Mostrar el resultado
cv2.imshow("Resultado NOT", resultado_not)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC

*** 5. Aplicaciones Prácticas
Las operaciones bitwise son útiles en muchas aplicaciones, como:

- **Enmascaramiento**: Puedes usar una máscara para seleccionar ciertas partes de una imagen y realizar operaciones solo en esas áreas.
- **Fusión de imágenes**: Combinar dos imágenes de manera controlada.
- **Operaciones en regiones de interés (ROI)**: Manipular partes específicas de una imagen sin afectar el resto.

Por ejemplo, puedes crear una máscara que seleccione solo una región de interés en una imagen y aplicar una operación bitwise AND para enfocarte en esa área.

#+BEGIN_SRC python
# Leer una imagen en color
img = cv2.imread("ruta/a/tu/imagen.jpg")

# Crear una máscara (un círculo en el centro de la imagen)
mascara = np.zeros(img.shape[:2], dtype="uint8")
cv2.circle(mascara, (img.shape[1]//2, img.shape[0]//2), 100, 255, -1)

# Aplicar bitwise AND para extraer solo el área dentro del círculo
resultado_mascara = cv2.bitwise_and(img, img, mask=mascara)

# Mostrar la imagen original, la máscara y el resultado
cv2.imshow("Imagen Original", img)
cv2.imshow("Máscara", mascara)
cv2.imshow("Resultado con Máscara", resultado_mascara)
cv2.waitKey(0)
cv2.destroyAllWindows()
#+END_SRC

*** Definición: Operación Bit a Bit

Una **operación bit a bit** (en inglés, *bitwise operation*) es una operación que se realiza directamente sobre los bits de los operandos. Las operaciones se ejecutan sobre los bits correspondientes de los números en formato binario.

**** Principales operaciones bit a bit

***** 1. AND bit a bit (~&~)
Devuelve `1` si ambos bits en la misma posición son `1`, de lo contrario devuelve `0`.

#+BEGIN_EXAMPLE
A = 1010 (10 en decimal)
B = 1100 (12 en decimal)
Resultado: 1000 (8 en decimal)
#+END_EXAMPLE

***** 2. OR bit a bit (~|~)
Devuelve `1` si al menos uno de los bits en la misma posición es `1`, de lo contrario devuelve `0`.

#+BEGIN_EXAMPLE
A = 1010 (10 en decimal)
B = 1100 (12 en decimal)
Resultado: 1110 (14 en decimal)
#+END_EXAMPLE

***** 3. XOR bit a bit (~^~)
Devuelve `1` si los bits en la misma posición son diferentes, y `0` si son iguales.

#+BEGIN_EXAMPLE
A = 1010 (10 en decimal)
B = 1100 (12 en decimal)
Resultado: 0110 (6 en decimal)
#+END_EXAMPLE

***** 4. NOT bit a bit (~~)
Invierte los bits de un número: convierte los `0` en `1` y los `1` en `0`. En sistemas de complemento a dos, esto también implica cambiar el signo de un número entero.

#+BEGIN_EXAMPLE
A = 1010 (10 en decimal)
Resultado: 0101 (-11 en decimal, si estamos usando complemento a dos)
#+END_EXAMPLE

***** 5. Desplazamiento a la izquierda (~<<~)
Desplaza todos los bits del número hacia la izquierda por un número específico de posiciones. Los bits desplazados fuera del límite se descartan y se rellenan con ceros en el extremo derecho.

#+BEGIN_EXAMPLE
A = 0001 (1 en decimal)
A << 2 = 0100 (4 en decimal)
#+END_EXAMPLE

***** 6. Desplazamiento a la derecha (~>>~)
Desplaza todos los bits del número hacia la derecha por un número específico de posiciones. Los bits desplazados fuera del límite se descartan y el bit más significativo depende del signo del número.

#+BEGIN_EXAMPLE
A = 1000 (8 en decimal)
A >> 2 = 0010 (2 en decimal)
#+END_EXAMPLE

***** Aplicaciones de las operaciones bit a bit

- **Máscaras de bits**: Las operaciones bit a bit se usan para aplicar máscaras que seleccionan o modifican partes específicas de un número o secuencia binaria.
- **Manipulación de imágenes**: En procesamiento de imágenes, las operaciones bit a bit son útiles para combinar y modificar píxeles en OpenCV.
- **Optimización de algoritmos**: Las operaciones bit a bit permiten optimizar cálculos en sistemas de bajo nivel o con restricciones de recursos.








#+BEGIN_SRC python :results output
import numpy as np 
import cv2 as cv

#img = np.ones((500,500), dtype=np.uint8)*255
img = cv.imread('tr.png', 1)
x,y=img.shape[:2]
img2 = np.zeros((x,y), dtype=np.uint8)

print(img.shape, x , y)
r,g,b =cv.split(img)

result = cv.merge([g,b,r])
#rr=cv.merge([r,img2,img2])
#gg=cv.merge([img2,g,img2])
#bb=cv.merge([img2,img2,b])
cv.imshow('img', result)
#cv.imshow('r', r)
#cv.imshow('g', g)
#cv.imshow('b', b)
#cv.imshow('rr', rr)
#cv.imshow('gg', gg)
#cv.imshow('bb', bb)
cv.waitKey()
cv.destroyAllWindows()

#+END_SRC

#+RESULTS:
: (632, 635, 3) 632 635

#+BEGIN_SRC python
import numpy as np 
import cv2 as cv

img = cv.imread('tr.png', 0)
x,y=img.shape
img2 = np.zeros((x*2,y*2), dtype=np.uint8)

for i in range(x):
    for j in range(y):
        img2[int(i*0.5),int(j*0.5)] = img[i,j]
    
cv.imshow('img', img2)
cv.waitKey()
cv.destroyAllWindows()
#+END_SRC

#+BEGIN_SRC python
import numpy as np
import cv2 as cv

img = cv.imread('tr.png', 0)
x,y=img.shape
img2 = np.zeros((x,y), dtype=np.uint8)

for i in range(x):
    for j in range(y):
        if img[i,j]>150:
            img2[i,j] = 255
        else:
            img2[i,j] = 0
            
cv.imshow('img', img2)
cv.waitKey()
cv.destroyAllWindows()
#+END_SRC

#+BEGIN_SRC python
import cv2 as cv
cap = cv.VideoCapture(0)
while(True):
         ret, img = cap.read()
	 if ret == True:
                  #img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
                  img3 = cv.cvtColor(img, cv.COLOR_BGR2HSV)
		  cv.imshow('video', img3)
		  k =cv.waitKey(1) & 0xFF
		  if k == 27 :
			   break
	 else:
		  break
cap.release()
cv.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None


,#+RESULTS:
: None







,#+BEGIN_SRC python
import cv2 as cv
import numpy as np

img = np.ones((500, 500), dtype=np.uint8)*156
cv.imshow('img', img)
cv.waitKey()
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:






#+BEGIN_SRC c :result output

#include <stdio.h>

typedef struct nodo{
int dato;
char info;
struct nodo *sig;
struct nodo *ant;
}nodo;

int main(){


}

#+END_SRC

** Segmentación de color mediante el modelo de color HSV

#+BEGIN_SRC python
import cv2 as cv

img = cv.imread('man1.jpg', 1)
hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)
uba=(10, 255, 255)
ubb=(0, 40 ,40)
uba2=(180, 255, 255)
ubb2=(170, 40,40)
mask1 = cv.inRange(hsv, ubb, uba)
mask2 = cv.inRange(hsv, ubb2, uba2)
mask = mask1+mask2
res = cv.bitwise_and(img, img, mask=mask)
cv.imshow('mask1', mask1)
cv.imshow('mask2', mask2)

cv.imshow('res', res)
cv.imshow('hsv', hsv )
cv.imshow('img', img)

cv.waitKey()
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None

#+BEGIN_SRC python
import cv2 as cv
import numpy as np
cap = cv.VideoCapture(0)

while(True):
    ret, img = cap.read()
    if ret:
        cv.imshow('video', img)
        hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)
        uba=(90, 255, 255)
        ubb=(40, 40 ,40)
        mask = cv.inRange(hsv, ubb, uba)
        res = cv.bitwise_and(img, img, mask=mask)
        cv.imshow('res', res)
        
        k =cv.waitKey(1) & 0xFF
        if k == 27 :
	    break
    else:
        break
    
cap.release()
cv.destroyAllWindows()
#+END_SRC

#+RESULTS:
: None









** Seguimiento Por color 

#+BEGIN_SRC python 
import cv2
import numpy as np

# Iniciar la captura de video desde la cámara
cap = cv2.VideoCapture(0)
# Definir el rango de color que quieres rastrear en el espacio de color HSV (en este caso, azul)
lower_blue = np.array([100, 150, 0])
upper_blue = np.array([140, 255, 255])
img2=None
i=0
while True:
    # Capturar frame por frame
    ret, frame = cap.read()
    if not ret:
        break
    
    # Convertir el frame de BGR a HSV
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    
    # Crear una máscara que detecte solo el color azul
    mask = cv2.inRange(hsv, lower_blue, upper_blue)
    
    # Filtrar la máscara con operaciones morfológicas
    mask = cv2.erode(mask, None, iterations=2)
    mask = cv2.dilate(mask, None, iterations=2)
    
    # Encontrar contornos en la máscara
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    # Si se encuentra al menos un contorno, seguir el objeto
    if contours:
        # Tomar el contorno más grande
        largest_contour = max(contours, key=cv2.contourArea)
        
        # Encontrar el centro del contorno usando un círculo mínimo que lo rodee
        ((x, y), radius) = cv2.minEnclosingCircle(largest_contour)
        
        # Dibujar el círculo y el centro en el frame original si el radio es mayor que un umbral
        if radius > 10:
            i=i+1
            cv2.circle(frame, (int(x), int(y)), int(radius), (0, 255, 255), 2)
            cv2.circle(frame, (int(x), int(y)), 5, (0, 255, 255), -1)
            cv2.rectangle(frame, (int(x-radius), int(y-radius)), (int(x+radius), int(y+radius)), (0, 0, 255), 3)
            img2 = frame[int(y-radius):int(y+radius), int(x-radius):int(x+radius)]
            cv2.imwrite("/home/likcos/tarjeta/tarjeta"+str(i)+'.jpg', img2)
            cv2.imshow('img2', img2)
    # Mostrar el frame
    cv2.imshow('Frame', frame)
    cv2.imshow('img2', img2)
    cv2.imshow('Mask', mask)

    # Salir si se presiona la tecla 'q'
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Liberar la captura y cerrar todas las ventanas
cap.release()
cv2.destroyAllWindows()

#+END_SRC

#+RESULTS:
: None






** Problemas con Objetos y Estructuras de Datos

*** Problema ejemplo: Control de un brazo robótico con múltiples articulaciones
   Diseña un sistema de control para un brazo robótico con 4 articulaciones (hombro, codo, muñeca y pinza), donde cada articulación tiene sensores de posición y motores controlados individualmente. El sistema debe recibir órdenes de movimiento y controlar la posición de cada articulación para mover el brazo hacia una posición objetivo en un espacio tridimensional.

**** Objetivo:
   Crear una estructura de datos que represente las articulaciones y los estados de cada una, así como un algoritmo que controle el brazo robótico basado en estos datos.

**** Requisitos:
   1. **Estructura de datos**:
      Cada articulación debe tener al menos los siguientes parámetros:
      - Ángulo actual
      - Ángulo objetivo
      - Velocidad de movimiento
      - Tipo de movimiento (rotación o deslizamiento, dependiendo de la articulación)
      - Límites máximos y mínimos de ángulo

   2. **Objeto articulación**:
      - Crea una clase "Articulación" con los atributos mencionados y métodos para actualizar el estado de cada articulación.
   
   3. **Clase brazo robótico**:
      - Implementa una clase "BrazoRobotico" que contenga un conjunto de objetos "Articulación". Esta clase debe tener métodos para:
        - Recibir una posición final y calcular los ángulos necesarios para cada articulación.
        - Actualizar las posiciones actuales de cada articulación con base en los valores de los sensores.
        - Mover cada articulación de manera sincronizada hacia su ángulo objetivo.

   4. **Resolución cinemática inversa**:
      - Desarrolla una función que calcule los ángulos objetivos de cada articulación dado un punto objetivo en el espacio tridimensional.

   5. **Planificación de trayectorias**:
      - Implementa una función que permita suavizar el movimiento del brazo robótico para evitar movimientos bruscos, calculando trayectorias intermedias a lo largo del recorrido.

**** Ejemplo de estructura de datos en Python:

#+begin_src python :results output
class Articulacion:
    def __init__(self, angulo_actual, angulo_objetivo, velocidad, limite_min, limite_max):
        self.angulo_actual = angulo_actual
        self.angulo_objetivo = angulo_objetivo
        self.velocidad = velocidad
        self.limite_min = limite_min
        self.limite_max = limite_max

    def actualizar_posicion(self):
        if self.angulo_actual < self.angulo_objetivo:
            self.angulo_actual += self.velocidad
            if self.angulo_actual > self.angulo_objetivo:
                self.angulo_actual = self.angulo_objetivo
        elif self.angulo_actual > self.angulo_objetivo:
            self.angulo_actual -= self.velocidad
            if self.angulo_actual < self.angulo_objetivo:
                self.angulo_actual = self.angulo_objetivo

class BrazoRobotico:
    def __init__(self):
        self.hombro = Articulacion(0, 0, 1, -90, 90)
        self.codo = Articulacion(0, 0, 1, 0, 135)
        self.muneca = Articulacion(0, 0, 1, -90, 90)
        self.pinza = Articulacion(0, 0, 1, 0, 180)

    def mover_a_posicion(self, posiciones_objetivo):
        # Calcula las posiciones objetivo para cada articulación y actualiza
        self.hombro.angulo_objetivo = posiciones_objetivo[0]
        self.codo.angulo_objetivo = posiciones_objetivo[1]
        self.muneca.angulo_objetivo = posiciones_objetivo[2]
        self.pinza.angulo_objetivo = posiciones_objetivo[3]

        # Actualiza cada articulación
        self.hombro.actualizar_posicion()
        self.codo.actualizar_posicion()
        self.muneca.actualizar_posicion()
        self.pinza.actualizar_posicion()

# Ejemplo de uso
brazo = BrazoRobotico()
brazo.mover_a_posicion([45, 90, 30, 180])
#+end_src

#+RESULTS:



*** 1. Sistema de gestión de energía en un vehículo eléctrico
   Diseña un sistema para gestionar la distribución de energía en un
   vehículo eléctrico. El sistema debe tener una clase Batería, con
   atributos como capacidad actual, capacidad máxima, y eficiencia de
   carga. Además, debe tener una clase Motor que controle el consumo
   de energía. La estructura de datos se debe utilizar para monitorear
   el estado de la batería y del motor, optimizando el rendimiento del
   vehículo.

   - Estructura de datos: Objeto batería, objeto motor.
   - Clases: Batería, Motor, GestorEnergía.

*** 2. Control de un dron con múltiples sensores
   Desarrolla un sistema para controlar un dron que utiliza varios
   sensores (acelerómetro, giroscopio, GPS, cámara). Cada sensor tiene
   su propia clase con atributos como frecuencia de actualización,
   precisión, y datos actuales. El sistema debe combinar los datos de
   estos sensores para mantener la estabilidad del dron y planear
   rutas de vuelo.

   - Estructura de datos: Objetos para cada sensor.
   - Clases: Acelerometro, Giroscopio, GPS, Camara, ControladorDron.

*** 3. Sistema de monitoreo de un invernadero automatizado
   Diseña un sistema para monitorear y controlar la temperatura,
   humedad, luz y nivel de nutrientes en un invernadero
   automatizado. Cada variable (temperatura, humedad, etc.) debe ser
   representada por una clase que registre su estado actual y
   objetivo. Un controlador central utiliza estas estructuras de datos
   para ajustar los actuadores que controlan el clima y los
   nutrientes.

   - Estructura de datos: Objetos de estado de temperatura, humedad, etc.
   - Clases: SensorTemperatura, SensorHumedad, ActuadorLuz, ControladorInvernadero.

*** 4. Sistema de estacionamiento automatizado
   Diseña un sistema para controlar un vehículo autónomo que puede
   estacionarse en un lugar designado. El vehículo tiene varios
   sensores de proximidad, un sistema de cámara y un motor controlado
   por una unidad de procesamiento. La posición y los obstáculos se
   gestionan mediante objetos que representan el entorno. El vehículo
   debe calcular la ruta óptima utilizando algoritmos de planificación
   de trayectoria.

   - Estructura de datos: Objetos para los sensores, cámara, motor,
     entorno.
   - Clases: SensorProximidad, Camara, Motor, EntornoEstacionamiento, VehiculoAutonomo.

*** 5. Control de un exoesqueleto
   Desarrolla un sistema para controlar un exoesqueleto mecánico que
   ayuda a personas con movilidad reducida a caminar. Cada
   articulación del exoesqueleto tiene un sensor que mide su posición
   y un actuador que controla el movimiento. Los datos de las
   articulaciones se gestionan con objetos, y el sistema debe
   sincronizar los movimientos de manera natural.

   - Estructura de datos: Objetos para articulaciones y actuadores.
   - Clases: ArticulacionExoesqueleto, Sensor, Actuador, ControlExoesqueleto.

*** 6. Sistema de control de calidad en una línea de producción
   Implementa un sistema para inspeccionar productos en una línea de
   producción automatizada. Se utilizan cámaras y sensores para
   verificar si los productos cumplen con las especificaciones. Cada
   producto es representado por un objeto que almacena sus
   características (dimensiones, peso, color, etc.). Los datos de los
   sensores se usan para aceptar o rechazar productos según las
   tolerancias establecidas.

   - Estructura de datos: Objetos para productos y sensores.
   - Clases: Producto, Camara, SensorDimensiones, ControlCalidad.


** Manejo de Archivos en Python

*** 1. ¿Qué es el manejo de archivos en Python?
El manejo de archivos es una técnica fundamental en programación que
permite la lectura, escritura, modificación y almacenamiento de datos
en archivos. Los archivos se utilizan para guardar información de
manera persistente, lo que significa que los datos no se pierden al
terminar la ejecución de un programa, a diferencia de las variables
que solo almacenan datos temporalmente en la memoria RAM.

Python ofrece una interfaz simple y poderosa para trabajar con
archivos, lo que te permite manipular archivos de texto, archivos
binarios, y otros formatos como JSON o CSV. Las operaciones más
comunes son abrir, leer, escribir y cerrar archivos.

*** 2. Tipos de archivos y sus modos de acceso

**** 2.1 Tipos de archivos
En general, los archivos se dividen en dos categorías principales:
- **Archivos de texto**: Estos archivos contienen datos en formato de texto simple, como archivos `.txt` o `.csv`. Los datos se almacenan como una secuencia de caracteres, fácilmente legible por humanos.
- **Archivos binarios**: Estos archivos contienen datos en formato binario, es decir, en 1s y 0s, como archivos de imágenes, videos, o archivos de ejecución. Este formato no es legible por humanos directamente.

**** 2.2 Modos de apertura de archivos
Cuando trabajamos con archivos, es esencial abrirlos en el modo adecuado. Python nos proporciona varios modos:

| Modo | Descripción |
|------|-------------|
| 'r'  | Modo de lectura. El archivo debe existir previamente. |
| 'w'  | Modo de escritura. Si el archivo existe, se sobrescribe. Si no, se crea. |
| 'a'  | Modo de anexado. Añade datos al final del archivo. Si no existe, lo crea. |
| 'b'  | Modo binario. Se usa junto con otros modos para leer o escribir archivos binarios. |
| 'r+' | Modo de lectura y escritura. El archivo debe existir previamente. |
| 'w+' | Modo de lectura y escritura, pero sobrescribiendo el contenido. |
| 'a+' | Modo de lectura y escritura, pero añadiendo datos al final del archivo. |

*** 3. Operaciones comunes en archivos
Python permite realizar varias operaciones con archivos:

**** 3.1 Abrir y cerrar un archivo
Para interactuar con un archivo, primero debes abrirlo utilizando la función `open()`. Al finalizar las operaciones, se debe cerrar el archivo con `close()` para liberar los recursos.

#+begin_src python
archivo = open('mi_archivo.txt', 'r')  # Abre el archivo en modo lectura
# Realiza operaciones con el archivo
archivo.close()  # Cierra el archivo
#+end_src

Para simplificar la gestión de archivos, Python recomienda usar el contexto `with` para abrir archivos, ya que se cierran automáticamente al terminar el bloque:

#+begin_src python
with open('mi_archivo.txt', 'r') as archivo:
    # Realiza operaciones con el archivo
    contenido = archivo.read()
# No es necesario cerrar el archivo
#+end_src

**** 3.2 Leer archivos
Python ofrece múltiples formas de leer archivos:
- **`read()`**: Lee todo el contenido del archivo como una cadena de texto.
- **`readline()`**: Lee una línea del archivo a la vez.
- **`readlines()`**: Lee todas las líneas del archivo y las devuelve como una lista.

Ejemplos de lectura:

#+begin_src python
with open('mi_archivo.txt', 'r') as archivo:
    contenido_completo = archivo.read()  # Lee todo el contenido
    primera_linea = archivo.readline()  # Lee solo la primera línea
    todas_las_lineas = archivo.readlines()  # Lee todas las líneas como una lista
#+end_src

**** 3.3 Escribir archivos
Para escribir en un archivo, puedes utilizar `write()` o `writelines()`. Es importante abrir el archivo en modo de escritura ('w') o anexado ('a').

#+begin_src python
with open('mi_archivo.txt', 'w') as archivo:
    archivo.write('Primera línea\n')
    archivo.write('Segunda línea\n')
#+end_src

Para escribir múltiples líneas a la vez, puedes usar `writelines()` con una lista:

#+begin_src python
lineas = ['Primera línea\n', 'Segunda línea\n', 'Tercera línea\n']
with open('mi_archivo.txt', 'w') as archivo:
    archivo.writelines(lineas)
#+end_src

**** 3.4 Manejo de errores
Es fundamental manejar posibles errores al interactuar con archivos,
como archivos no encontrados o problemas de permisos. Esto se logra
mediante el uso de bloques `try-except`:

#+begin_src python
try:
    with open('mi_archivo.txt', 'r') as archivo:
        contenido = archivo.read()
except FileNotFoundError:
    print("El archivo no fue encontrado.")
#+end_src





*** 4. Ejemplos prácticos

A continuación se presenta el tutorial original que utiliza las clases
*Articulacion* y *BrazoRobotico*. Este código demuestra cómo escribir
y leer las posiciones del brazo robótico desde un archivo de texto,
además de ejemplos avanzados como el uso de JSON.

**** 1. Definición básica del código
A continuación se muestra el código que define las clases *Articulacion* y *BrazoRobotico*.

#+begin_src python
class Articulacion:
    def __init__(self, angulo_actual, angulo_objetivo, velocidad, limite_min, limite_max):
        self.angulo_actual = angulo_actual
        self.angulo_objetivo = angulo_objetivo
        self.velocidad = velocidad
        self.limite_min = limite_min
        self.limite_max = limite_max

    def actualizar_posicion(self):
        if self.angulo_actual < self.angulo_objetivo:
            self.angulo_actual += self.velocidad
            if self.angulo_actual > self.angulo_objetivo:
                self.angulo_actual = self.angulo_objetivo
        elif self.angulo_actual > self.angulo_objetivo:
            self.angulo_actual -= self.velocidad
            if self.angulo_actual < self.angulo_objetivo:
                self.angulo_actual = self.angulo_objetivo

class BrazoRobotico:
    def __init__(self):
        self.hombro = Articulacion(0, 0, 1, -90, 90)
        self.codo = Articulacion(0, 0, 1, 0, 135)
        self.muneca = Articulacion(0, 0, 1, -90, 90)
        self.pinza = Articulacion(0, 0, 1, 0, 180)

    def mover_a_posicion(self, posiciones_objetivo):
        self.hombro.angulo_objetivo = posiciones_objetivo[0]
        self.codo.angulo_objetivo = posiciones_objetivo[1]
        self.muneca.angulo_objetivo = posiciones_objetivo[2]
        self.pinza.angulo_objetivo = posiciones_objetivo[3]

        self.hombro.actualizar_posicion()
        self.codo.actualizar_posicion()
        self.muneca.actualizar_posicion()
        self.pinza.actualizar_posicion()
#+end_src

Este código define la estructura básica del brazo robótico con
articulaciones como el hombro, codo, muñeca y pinza.

**** 2. Escribir las posiciones del brazo en un archivo
La primera tarea es escribir las posiciones actuales de las
articulaciones a un archivo de texto. Puedes utilizar el método
`open()` en modo de escritura.

#+begin_src python
    def guardar_posiciones(self, nombre_archivo):
        with open(nombre_archivo, 'w') as archivo:
            archivo.write(f'Hombro: {self.hombro.angulo_actual}\n')
            archivo.write(f'Codo: {self.codo.angulo_actual}\n')
            archivo.write(f'Muñeca: {self.muneca.angulo_actual}\n')
            archivo.write(f'Pinza: {self.pinza.angulo_actual}\n')
#+end_src

**** 3. Leer las posiciones desde un archivo
Puedes leer los datos del archivo y asignarlos a las articulaciones
del brazo robótico utilizando `readlines()` para leer todas las líneas
del archivo y luego dividirlas.

#+begin_src python
    def cargar_posiciones(self, nombre_archivo):
        with open(nombre_archivo, 'r') as archivo:
            lineas = archivo.readlines()
            self.hombro.angulo_actual = float(lineas[0].split(': ')[1].strip())
            self.codo.angulo_actual = float(lineas[1].split(': ')[1].strip())
            self.muneca.angulo_actual = float(lineas[2].split(': ')[1].strip())
            self.pinza.angulo_actual = float(lineas[3].split(': ')[1].strip())
#+end_src

Este método lee las posiciones del archivo y las asigna a las articulaciones del brazo robótico.

**** 4. Diferentes maneras de recorrer un archivo
Hay varias formas de recorrer el contenido de un archivo. Veamos algunas:

***** 4.1 Leer todo el archivo como una sola cadena
Puedes leer todo el contenido de un archivo como una cadena de texto utilizando `read()`.

#+begin_src python
with open('posiciones_brazo.txt', 'r') as archivo:
    contenido = archivo.read()
    print(contenido)
#+end_src

Esto imprimirá todo el contenido del archivo en un solo bloque.

***** 4.2 Leer línea por línea
Si deseas procesar el archivo línea por línea, puedes usar un bucle `for`.

#+begin_src python
with open('posiciones_brazo.txt', 'r') as archivo:
    for linea in archivo:
        print(linea.strip())  # Remueve los espacios y saltos de línea
#+end_src

Esto imprimirá cada línea del archivo de manera individual, eliminando
saltos de línea innecesarios.

***** 4.3 Usar el formato JSON para guardar y cargar posiciones
Otra opción avanzada es usar archivos JSON, lo cual es útil para
almacenar estructuras de datos más complejas.

#+begin_src python
import json

def guardar_en_json(self, nombre_archivo):
    datos = {
        'hombro': self.hombro.angulo_actual,
        'codo': self.codo.angulo_actual,
        'muneca': self.muneca.angulo_actual,
        'pinza': self.pinza.angulo_actual
    }
    with open(nombre_archivo, 'w') as archivo:
        json.dump(datos, archivo)

def cargar_desde_json(self, nombre_archivo):
    with open(nombre_archivo, 'r') as archivo:
        datos = json.load(archivo)
        self.hombro.angulo_actual = datos['hombro']
        self.codo.angulo_actual = datos['codo']
        self.muneca.angulo_actual = datos['muneca']
        self.pinza.angulo_actual = datos['pinza']
#+end_src

En este caso, el formato JSON permite almacenar las posiciones de
manera más estructurada y fácilmente interpretable por otros
programas.

**** 5. Búsqueda y filtrado de información en el archivo
A continuación, mostramos cómo buscar información específica en un
archivo.

***** 5.1 Buscar por palabra clave
Podemos buscar una palabra clave en el archivo para encontrar articulaciones específicas.

#+begin_src python
def buscar_articulacion(nombre_archivo, articulacion):
    with open(nombre_archivo, 'r') as archivo:
        for linea in archivo:
            if articulacion in linea:
                print(linea.strip())

# Ejemplo de uso
buscar_articulacion('posiciones_brazo.txt', 'Codo')
#+end_src

Esto buscará la palabra "Codo" en el archivo y devolverá la línea correspondiente.

***** 5.2 Filtrar con expresiones regulares
Para una búsqueda más avanzada, podemos usar expresiones regulares con el módulo `re`.

#+begin_src python
import re

def buscar_con_regex(nombre_archivo, patron):
    with open(nombre_archivo, 'r') as archivo:
        for linea in archivo:
            if re.search(patron, linea):
                print(linea.strip())

# Ejemplo de uso
buscar_con_regex('posiciones_brazo.txt', r'Hombro:\s[4-5][0-9]')
#+end_src

En este caso, la expresión regular busca valores del ángulo del hombro
entre 40 y 59 grados.

**** 6. Manejo de errores

Al trabajar con archivos, es importante manejar errores para evitar
fallos inesperados, como archivos no encontrados.

#+begin_src python
def cargar_posiciones_seguro(nombre_archivo):
    try:
        with open(nombre_archivo, 'r') as archivo:
            lineas = archivo.readlines()
            # Procesa las líneas del archivo
    except FileNotFoundError:
        print(f"Error: El archivo {nombre_archivo} no fue encontrado.")
#+end_src

Este código asegura que el programa no se rompa si el archivo no existe.

** Tipos de archivos JSON y CSV

*** 1.1 ¿Qué es JSON?
JSON (JavaScript Object Notation) es un formato ligero para el
intercambio de datos. Es fácil de leer y escribir tanto para humanos
como para máquinas. Aunque tiene sus raíces en JavaScript, es un
formato independiente del lenguaje y ampliamente utilizado,
especialmente en APIs y aplicaciones web.

*** 1.2 Estructura de un archivo JSON
Los archivos JSON están organizados en pares de clave-valor, y pueden representar objetos complejos o listas anidadas. Un ejemplo básico de un archivo JSON sería:

#+begin_example json
{
    "nombre": "Brazo Robótico",
    "hombro": 45,
    "codo": 90,
    "muneca": 30,
    "pinza": 180
}
#+end_example

Cada campo tiene una clave (ejemplo: `"nombre"`, `"hombro"`) y un valor que puede ser un número, cadena, objeto o lista.

*** 1.3 Ventajas de JSON
- **Fácil de leer y escribir**: Tanto para humanos como para máquinas.
- **Ligero**: Ocupa poco espacio.
- **Amplia compatibilidad**: Casi todos los lenguajes de programación pueden manipular archivos JSON.
  
*** 1.4 Trabajar con JSON en Python
Python proporciona el módulo `json` para manejar archivos JSON de forma nativa.

- **Escribir un archivo JSON** (serialización):

#+begin_src python
import json

datos = {
    "nombre": "Brazo Robótico",
    "hombro": 45,
    "codo": 90,
    "muneca": 30,
    "pinza": 180
}

with open('datos_brazo.json', 'w') as archivo:
    json.dump(datos, archivo)  # Guarda los datos en formato JSON
#+end_src

- **Leer un archivo JSON** (deserialización):

#+begin_src python
with open('datos_brazo.json', 'r') as archivo:
    datos = json.load(archivo)
    print(datos)
#+end_src

*** 2. Archivos CSV
**** 2.1 ¿Qué es CSV?
CSV (Comma-Separated Values) es un formato simple utilizado para
almacenar datos tabulares (como una hoja de cálculo o base de datos)
en texto plano. Los campos están separados por comas y cada línea es
un registro de datos.

**** 2.2 Estructura de un archivo CSV
Un archivo CSV puede verse de la siguiente manera:

#+begin_example csv
nombre,hombro,codo,muneca,pinza
Brazo Robótico,45,90,30,180
#+end_example

La primera línea es el encabezado (opcional), que describe los campos. Cada línea siguiente es un registro, con los valores separados por comas.

**** 2.3 Ventajas de CSV
- **Simplicidad**: Fácil de usar y entender.
- **Universalidad**: Es soportado por muchos programas (como Excel) y lenguajes de programación.
- **Ligero**: El tamaño del archivo es mínimo, ideal para grandes volúmenes de datos tabulares.

**** 2.4 Trabajar con CSV en Python
Python proporciona el módulo `csv` para leer y escribir archivos CSV.

- **Escribir un archivo CSV**:

#+begin_src python
import csv

datos = [
    ['nombre', 'hombro', 'codo', 'muneca', 'pinza'],
    ['Brazo Robótico', 45, 90, 30, 180]
]

with open('datos_brazo.csv', 'w', newline='') as archivo:
    escritor = csv.writer(archivo)
    escritor.writerows(datos)
#+end_src

- **Leer un archivo CSV**:

#+begin_src python
with open('datos_brazo.csv', 'r') as archivo:
    lector = csv.reader(archivo)
    for fila in lector:
        print(fila)
#+end_src

*** 3. Comparación entre JSON y CSV
| Característica   | JSON                                      | CSV                                   |
|------------------|-------------------------------------------|---------------------------------------|
| **Formato**      | Pares de clave-valor, estructura jerárquica | Valores separados por comas, tabular   |
| **Uso**          | Ideal para datos estructurados complejos   | Mejor para datos tabulares simples    |
| **Legibilidad**  | Fácil de leer y entender                   | Fácil de leer pero menos flexible     |
| **Manipulación** | Adecuado para datos anidados o jerárquicos | Adecuado para datos en formato de tabla |
| **Tamaño**       | Puede ser más grande debido a su estructura | Ligero, tamaño reducido               |


Los archivos JSON y CSV son dos de los formatos de almacenamiento de
datos más utilizados en programación. JSON es ideal para representar
estructuras de datos complejas o anidadas, mientras que CSV es
perfecto para datos tabulares simples que pueden abrirse en programas
como Excel o Google Sheets. Python facilita trabajar con ambos
formatos mediante sus módulos *json* y *csv*, permitiendo la
serialización y deserialización de datos de forma sencilla.
** Excepciones en el manejo de archivos en Python

*** 1. ¿Qué son las excepciones en Python?
Una excepción es un error que ocurre durante la ejecución de un
programa, interrumpiendo el flujo normal del mismo. En Python, cuando
se produce un error, se lanza una "excepción" que, si no se maneja,
terminará el programa de manera abrupta.

Para evitar esto, se puede usar el manejo de excepciones mediante los
bloques `try-except`. Esto permite que, en caso de un error, el
programa capture la excepción y ejecute código alternativo.

Al trabajar con archivos, existen algunas excepciones comunes que pueden surgir, por ejemplo:

- El archivo no existe.
- No tienes permisos para abrir el archivo.
- Estás intentando leer un archivo que está en uso por otro proceso.

*** 2. Uso básico de `try-except` en archivos

Cuando trabajas con archivos en Python, es recomendable usar bloques
`try-except` para capturar errores comunes, como un archivo no
encontrado. Aquí te muestro cómo hacerlo:

#+begin_src python
try:
    with open('archivo_inexistente.txt', 'r') as archivo:
        contenido = archivo.read()
except FileNotFoundError:
    print("Error: El archivo no existe.")
#+end_src

En este caso, si el archivo no se encuentra, se lanza una excepción
`FileNotFoundError`, la cual es capturada por el bloque `except` y
evita que el programa se detenga de forma inesperada.

*** 3. Excepciones comunes en el manejo de archivos

Existen varias excepciones que pueden surgir cuando trabajas con archivos. Aquí te describo las más comunes:

**** 3.1 FileNotFoundError
Esta excepción se lanza cuando intentas abrir un archivo que no existe. Como vimos en el ejemplo anterior, puedes manejar este error con `except FileNotFoundError`.

#+begin_src python
try:
    with open('archivo_que_no_existe.txt', 'r') as archivo:
        contenido = archivo.read()
except FileNotFoundError:
    print("Error: El archivo no fue encontrado.")
#+end_src

**** 3.2 PermissionError
Este error ocurre cuando el programa no tiene permiso para acceder al archivo. Puede suceder, por ejemplo, si intentas abrir un archivo en un directorio protegido o si intentas escribir en un archivo de solo lectura.

#+begin_src python
try:
    with open('/archivo_protegido.txt', 'r') as archivo:
        contenido = archivo.read()
except PermissionError:
    print("Error: No tienes permisos para abrir este archivo.")
#+end_src

**** 3.3 IOError (OSError)
La excepción `IOError` (también conocida como `OSError` en Python 3) captura errores generales de entrada/salida que pueden ocurrir al trabajar con archivos. Por ejemplo, puede ocurrir si el archivo está en uso por otro proceso o si hay problemas con el sistema de archivos.

#+begin_src python
try:
    with open('archivo.txt', 'r') as archivo:
        contenido = archivo.read()
except IOError as e:
    print(f"Error de entrada/salida: {e}")
#+end_src

En este caso, el `IOError` puede capturar muchos errores relacionados con la entrada/salida de archivos, y al imprimir el error (`e`), se obtiene una descripción detallada del problema.

*** 4. Usar `finally` para asegurar el cierre de archivos
El bloque `finally` es muy útil para asegurarte de que ciertos bloques de código se ejecuten sin importar si ocurre una excepción. En el caso del manejo de archivos, es importante asegurarte de que el archivo se cierre correctamente, incluso si ocurre un error.

#+begin_src python
try:
    archivo = open('archivo.txt', 'r')
    contenido = archivo.read()
except Exception as e:
    print(f"Ocurrió un error: {e}")
finally:
    archivo.close()  # Se asegura que el archivo se cierre
#+end_src

Sin embargo, es mucho más común y recomendable usar el contexto `with` en Python, ya que cierra automáticamente el archivo incluso si ocurre un error.

#+begin_src python
try:
    with open('archivo.txt', 'r') as archivo:
        contenido = archivo.read()
except Exception as e:
    print(f"Ocurrió un error: {e}")
#+end_src

*** 5. Manejo de múltiples excepciones
Puedes manejar más de una excepción en un solo bloque `try-except`. Esto es útil si esperas varios tipos de errores posibles. Puedes usar varios bloques `except` para manejar distintos errores.

#+begin_src python
try:
    with open('archivo.txt', 'r') as archivo:
        contenido = archivo.read()
except FileNotFoundError:
    print("Error: El archivo no existe.")
except PermissionError:
    print("Error: No tienes permisos para acceder a este archivo.")
except Exception as e:
    print(f"Ocurrió un error inesperado: {e}")
#+end_src

Aquí estamos manejando tres posibles tipos de errores: archivo no encontrado, permisos denegados, y un error general para capturar cualquier otra excepción que no hayamos considerado específicamente.

*** 6. Crear excepciones personalizadas
En algunos casos, puede ser útil definir tus propias excepciones personalizadas para manejar situaciones específicas. En Python, puedes hacerlo creando una nueva clase que herede de `Exception`. Aquí tienes un ejemplo en el contexto del manejo de archivos:

#+begin_src python
class ArchivoVacioError(Exception):
    pass

try:
    with open('archivo.txt', 'r') as archivo:
        contenido = archivo.read()
        if not contenido:
            raise ArchivoVacioError("El archivo está vacío.")
except ArchivoVacioError as e:
    print(e)
except Exception as e:
    print(f"Ocurrió un error: {e}")
#+end_src

En este ejemplo, si el archivo está vacío, se lanza una excepción
personalizada `ArchivoVacioError`, que se maneja de manera específica
en el bloque `except`.

El manejo de excepciones es una herramienta poderosa en Python,
especialmente al trabajar con archivos, ya que los errores de
entrada/salida son comunes y pueden ocurrir de muchas formas. Con
`try-except` puedes asegurarte de que tu programa siga funcionando
incluso cuando ocurran errores inesperados, mejorando así la robustez
y fiabilidad de tu código.

Al usar excepciones comunes como `FileNotFoundError` o
`PermissionError`, junto con `finally` para garantizar el cierre
adecuado de archivos, puedes minimizar los riesgos de errores
inesperados y asegurar un manejo más seguro de tus archivos.
   
   




#+BEGIN_SRC c :result output

#include <stdio.h>

int main(){
int a=3;
printf("%d",a);
printf("%p",a);
 
return 0; 
}


#+END_SRC

**  Altas, Bajas, Modificaciones y Consultas

*** Introducción
  En el ámbito de la gestión de datos, ya sea en sistemas de bases de
  datos o aplicaciones de software, las operaciones de *altas*,
  *bajas*, *modificaciones* y *consultas* son esenciales para la
  correcta manipulación y mantenimiento de la información.

 
*** Definición de Altas, Bajas, Modificaciones y Consultas

**** Altas (Crear o Añadir un registro)
   La operación de *alta* se refiere a la creación de un nuevo
   registro dentro de un sistema de información. Este registro puede
   ser un nuevo usuario en una base de datos, una nueva entrada en un
   inventario, o cualquier conjunto de datos que necesite ser
   almacenado para su posterior uso.

   **Proceso**:
   1. Se recibe la información para crear el nuevo registro.
   2. La información es validada para asegurar su corrección.
   3. Los datos son almacenados en la base de datos o sistema correspondiente.

   **Ejemplo en Python**:
   En el siguiente ejemplo, se agrega un nuevo registro a un archivo JSON que simula una base de datos de usuarios:

   #+begin_src python :tangle src/gestion_registros.py :results output
   import json

   # Función para realizar el alta de un nuevo registro
   def alta_usuario(nombre, edad):
       nuevo_registro = {"nombre": nombre, "edad": edad}
       try:
           with open("usuarios.json", "r+") as file:
               datos = json.load(file)
               datos.append(nuevo_registro)
               file.seek(0)
               json.dump(datos, file, indent=4)
           print(f"Usuario {nombre} agregado exitosamente.")
       except FileNotFoundError:
           with open("usuarios.json", "w") as file:
               json.dump([nuevo_registro], file, indent=4)
           print(f"Archivo creado y usuario {nombre} agregado exitosamente.")

   alta_usuario("Juan", 28)
   #+end_src

   Este código gestiona el proceso de agregar un nuevo usuario a un archivo JSON, y crea el archivo si no existe.

**** Bajas (Eliminar un registro)
   La operación de *baja* implica la eliminación de un registro existente en el sistema. Generalmente se realiza cuando un registro ya no es necesario o cuando se desea eliminar información obsoleta o incorrecta.

   **Proceso**:
   1. Se identifica el registro que debe ser eliminado.
   2. Se verifica que el registro exista.
   3. El registro se elimina de la base de datos.

   **Ejemplo en Python**:
   En este ejemplo, eliminamos un usuario de la base de datos JSON basada en su índice.

   #+begin_src python :tangle src/gestion_registros.py :results output
   import json

   # Función para eliminar un registro basado en el índice
   def baja_usuario(indice):
       try:
           with open("usuarios.json", "r+") as file:
               datos = json.load(file)
               if 0 <= indice < len(datos):
                   usuario_eliminado = datos.pop(indice)
                   file.seek(0)
                   json.dump(datos, file, indent=4)
                   file.truncate()
                   print(f"Usuario {usuario_eliminado['nombre']} eliminado exitosamente.")
               else:
                   print("Índice fuera de rango.")
       except FileNotFoundError:
           print("No se encontró el archivo de usuarios.")

   baja_usuario(0)
   #+end_src

   Este código elimina el primer registro (índice 0) del archivo JSON de usuarios, asegurándose de verificar si el archivo existe y si el índice es válido.

**** Modificaciones (Actualizar un registro existente)
   La operación de *modificación* permite actualizar los datos de un registro existente en el sistema. Esto es necesario cuando la información cambia o cuando se necesita corregir datos incorrectos.

   **Proceso**:
   1. Se identifica el registro que debe modificarse.
   2. Se valida la nueva información a ser actualizada.
   3. Se actualiza el registro con la nueva información.

   **Ejemplo en Python**:
   A continuación, se muestra cómo modificar un registro específico en la base de datos.

   #+begin_src python :tangle src/gestion_registros.py :results output
   import json

   # Función para modificar un registro en base a su índice
   def modificar_usuario(indice, nuevo_nombre, nueva_edad):
       try:
           with open("usuarios.json", "r+") as file:
               datos = json.load(file)
               if 0 <= indice < len(datos):
                   datos[indice]["nombre"] = nuevo_nombre
                   datos[indice]["edad"] = nueva_edad
                   file.seek(0)
                   json.dump(datos, file, indent=4)
                   file.truncate()
                   print(f"Usuario en el índice {indice} modificado exitosamente.")
               else:
                   print("Índice fuera de rango.")
       except FileNotFoundError:
           print("No se encontró el archivo de usuarios.")

   modificar_usuario(0, "Ana", 30)
   #+end_src

   Este ejemplo actualiza el nombre y la edad del primer usuario (índice 0) en el archivo JSON.

**** Consultas (Visualizar o Buscar registros)
   La *consulta* permite visualizar o buscar información almacenada sin modificar los datos. Es fundamental para extraer datos útiles de la base de datos o lista de registros.

   **Proceso**:
   1. Se especifica un criterio de búsqueda o visualización.
   2. El sistema busca y devuelve los registros que coinciden con el criterio.

   **Ejemplo en Python**:
   A continuación, se muestran  todos los registros de usuarios almacenados en el archivo JSON.

   #+begin_src python :tangle src/gestion_registros.py :results output
   import json

   # Función para consultar y mostrar todos los registros
   def consultar_usuarios():
       try:
           with open("usuarios.json", "r") as file:
               datos = json.load(file)
               if datos:
                   for i, usuario in enumerate(datos):
                       print(f"Usuario {i}: {usuario['nombre']}, Edad: {usuario['edad']}")
               else:
                   print("No hay usuarios registrados.")
       except FileNotFoundError:
           print("No se encontró el archivo de usuarios.")

   consultar_usuarios()
   #+end_src

   Este código lee y muestra todos los usuarios almacenados en el archivo JSON.

*** Conclusión
  Las operaciones de *altas*, *bajas*, *modificaciones* y *consultas*
  forman la base de la gestión de datos en cualquier sistema que
  necesite almacenar, manipular y recuperar información. Implementar
  estas operaciones de manera correcta garantiza que los datos sean
  precisos y estén disponibles para el análisis y la toma de
  decisiones.




** Ejemplo persistente

#+begin_src python :results output :tangle code/archivos.py
import json
import os

class Articulacion:
    def __init__(self, angulo_actual, angulo_objetivo, velocidad, limite_min, limite_max):
        self.angulo_actual = angulo_actual
        self.angulo_objetivo = angulo_objetivo
        self.velocidad = velocidad
        self.limite_min = limite_min
        self.limite_max = limite_max

    def actualizar_posicion(self):
        if self.angulo_actual < self.angulo_objetivo:
            self.angulo_actual += self.velocidad
            if self.angulo_actual > self.angulo_objetivo:
                self.angulo_actual = self.angulo_objetivo
        elif self.angulo_actual > self.angulo_objetivo:
            self.angulo_actual -= self.velocidad
            if self.angulo_actual < self.angulo_objetivo:
                self.angulo_actual = self.angulo_objetivo

class BrazoRobotico:
    def __init__(self):
        self.hombro = Articulacion(0, 0, 1, -90, 90)
        self.codo = Articulacion(0, 0, 1, 0, 135)
        self.muneca = Articulacion(0, 0, 1, -90, 90)
        self.pinza = Articulacion(0, 0, 1, 0, 180)

    def mover_a_posicion(self, posiciones_objetivo):
        # Actualiza los ángulos objetivo para cada articulación
        self.hombro.angulo_objetivo = posiciones_objetivo[0]
        self.codo.angulo_objetivo = posiciones_objetivo[1]
        self.muneca.angulo_objetivo = posiciones_objetivo[2]
        self.pinza.angulo_objetivo = posiciones_objetivo[3]

        # Actualiza cada articulación
        self.hombro.actualizar_posicion()
        self.codo.actualizar_posicion()
        self.muneca.actualizar_posicion()
        self.pinza.actualizar_posicion()

    def obtener_posiciones(self):
        # Retorna las posiciones actuales de las articulaciones
        return {
            "hombro": self.hombro.angulo_actual,
            "codo": self.codo.angulo_actual,
            "muneca": self.muneca.angulo_actual,
            "pinza": self.pinza.angulo_actual
        }

class ManejoArchivos:
    def __init__(self, archivo):
        self.archivo = archivo
        # Crear archivo si no existe
        if not os.path.exists(self.archivo):
            with open(self.archivo, 'w') as f:
                json.dump([], f)

    def alta(self, datos):
        # Cargar los datos existentes
        with open(self.archivo, 'r') as f:
            registros = json.load(f)
        # Añadir nuevos datos
        registros.append(datos)
        # Guardar los cambios
        with open(self.archivo, 'w') as f:
            json.dump(registros, f, indent=4)

    def baja(self, indice):
        # Cargar los datos existentes
        with open(self.archivo, 'r') as f:
            registros = json.load(f)
        # Eliminar por índice
        if 0 <= indice < len(registros):
            registros.pop(indice)
        # Guardar los cambios
        with open(self.archivo, 'w') as f:
            json.dump(registros, f, indent=4)

    def modificar(self, indice, nuevos_datos):
        # Cargar los datos existentes
        with open(self.archivo, 'r') as f:
            registros = json.load(f)
        # Modificar el registro por índice
        if 0 <= indice < len(registros):
            registros[indice] = nuevos_datos
        # Guardar los cambios
        with open(self.archivo, 'w') as f:
            json.dump(registros, f, indent=4)

    def consultar(self):
        # Cargar los datos existentes
        with open(self.archivo, 'r') as f:
            registros = json.load(f)
        return registros

def mostrar_menu():
    print("\nMenú del Brazo Robótico:")
    print("1. Alta (Guardar nueva posición)")
    print("2. Baja (Eliminar una posición por índice)")
    print("3. Modificación (Modificar una posición por índice)")
    print("4. Consultas (Mostrar todas las posiciones guardadas)")
    print("5. Salir")
    return input("Seleccione una opción: ")

def main():
    brazo = BrazoRobotico()
    archivo = ManejoArchivos("articulaciones.json")

    while True:
        opcion = mostrar_menu()

        if opcion == "1":  # Alta
            # Captura nuevas posiciones de las articulaciones
            try:
                pos_hombro = float(input("Ángulo del hombro: "))
                pos_codo = float(input("Ángulo del codo: "))
                pos_muneca = float(input("Ángulo de la muñeca: "))
                pos_pinza = float(input("Ángulo de la pinza: "))
                brazo.mover_a_posicion([pos_hombro, pos_codo, pos_muneca, pos_pinza])
                archivo.alta(brazo.obtener_posiciones())
                print("Posición guardada exitosamente.")
            except ValueError:
                print("Error: Por favor ingrese valores numéricos válidos.")

        elif opcion == "2":  # Baja
            try:
                indice = int(input("Ingrese el índice de la posición que desea eliminar: "))
                archivo.baja(indice)
                print("Posición eliminada exitosamente.")
            except ValueError:
                print("Error: Ingrese un índice válido.")
            except IndexError:
                print("Error: Índice fuera de rango.")

        elif opcion == "3":  # Modificación
            try:
                indice = int(input("Ingrese el índice de la posición que desea modificar: "))
                pos_hombro = float(input("Nuevo ángulo del hombro: "))
                pos_codo = float(input("Nuevo ángulo del codo: "))
                pos_muneca = float(input("Nuevo ángulo de la muñeca: "))
                pos_pinza = float(input("Nuevo ángulo de la pinza: "))
                brazo.mover_a_posicion([pos_hombro, pos_codo, pos_muneca, pos_pinza])
                archivo.modificar(indice, brazo.obtener_posiciones())
                print("Posición modificada exitosamente.")
            except ValueError:
                print("Error: Ingrese valores numéricos válidos.")
            except IndexError:
                print("Error: Índice fuera de rango.")

        elif opcion == "4":  # Consultas
            posiciones = archivo.consultar()
            if posiciones:
                for i, pos in enumerate(posiciones):
                    print(f"Posición {i}: Hombro={pos['hombro']}, Codo={pos['codo']}, Muñeca={pos['muneca']}, Pinza={pos['pinza']}")
            else:
                print("No hay posiciones guardadas.")

        elif opcion == "5":  # Salir
            print("Saliendo del programa.")
            break

        else:
            print("Opción no válida. Por favor seleccione una opción del menú.")

if __name__ == "__main__":
    main()

#+end_src

#+RESULTS:

#+begin_src python :results output :tangle code/archivosd.py
import cv2
import numpy as np
import json
import os

# Funciones para manejar el registro de objetos detectados
def alta_objeto(color, tamano, area):
    nuevo_objeto = {"color": color, "tamano": tamano, "area": area}
    
    # Si el archivo existe, leer los datos existentes, sino crear uno nuevo
    try:
        if os.path.exists("detected_objects.json"):
            with open("detected_objects.json", "r") as file:
                datos = json.load(file)
        else:
            datos = []

        # Agregar el nuevo objeto detectado
        datos.append(nuevo_objeto)

        # Guardar los datos actualizados
        with open("detected_objects.json", "w") as file:
            json.dump(datos, file, indent=4)
        print("Nuevo objeto registrado.")
    except Exception as e:
        print(f"Error al registrar el objeto: {e}")

def consultar_objetos():
    try:
        with open("detected_objects.json", "r") as file:
            datos = json.load(file)
            if datos:
                for i, objeto in enumerate(datos):
                    print(f"Objeto {i}: Color={objeto['color']}, Tamaño={objeto['tamano']}, Área={objeto['area']}")
            else:
                print("No hay objetos registrados.")
    except FileNotFoundError:
        print("No se encontró el archivo de objetos detectados.")
    except json.JSONDecodeError:
        print("Error al leer el archivo JSON.")

# Iniciar la captura de video desde la cámara
cap = cv2.VideoCapture(0)

# Definir el rango de color que quieres rastrear en el espacio de color HSV (en este caso, azul)
lower_blue = np.array([100, 150, 0])
upper_blue = np.array([140, 255, 255])

img2 = None
i = 0

while True:
    # Capturar frame por frame
    ret, frame = cap.read()
    if not ret:
        break
    
    # Convertir el frame de BGR a HSV
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    
    # Crear una máscara que detecte solo el color azul
    mask = cv2.inRange(hsv, lower_blue, upper_blue)
    
    # Filtrar la máscara con operaciones morfológicas
    mask = cv2.erode(mask, None, iterations=2)
    mask = cv2.dilate(mask, None, iterations=2)
    
    # Encontrar contornos en la máscara
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    # Si se encuentra al menos un contorno, seguir el objeto
    if contours:
        # Tomar el contorno más grande
        largest_contour = max(contours, key=cv2.contourArea)
        
        # Encontrar el centro del contorno usando un círculo mínimo que lo rodee
        ((x, y), radius) = cv2.minEnclosingCircle(largest_contour)
        
        # Dibujar el círculo y el centro en el frame original si el radio es mayor que un umbral
        if radius > 10:
            i = i + 1
            cv2.circle(frame, (int(x), int(y)), int(radius), (0, 255, 255), 2)
            cv2.circle(frame, (int(x), int(y)), 5, (0, 255, 255), -1)
            cv2.rectangle(frame, (int(x-radius), int(y-radius)), (int(x+radius), int(y+radius)), (0, 0, 255), 3)
            img2 = frame[int(y-radius):int(y+radius), int(x-radius):int(x+radius)]
            cv2.imshow('img2', img2)
            
            # Calcular el área del objeto detectado
            area = cv2.contourArea(largest_contour)
            
            # Registrar el objeto detectado (alta)
            alta_objeto("azul", radius, area)
    
    # Mostrar el frame
    cv2.imshow('Frame', frame)
    
    # Salir si se presiona la tecla 'q'
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Consultar los objetos detectados
#consultar_objetos()

# Liberar la captura y cerrar todas las ventanas
cap.release()
cv2.destroyAllWindows()


#+end_src

#+RESULTS:
#+begin_example
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
Nuevo objeto registrado.
#+end_example



** Flet
Flet es una biblioteca de Python para crear aplicaciones de interfaz
de usuario (UI) en el navegador de forma fácil y rápida. Proporciona
una API simple que permite diseñar y construir interfaces web modernas
sin necesidad de conocimientos avanzados de HTML, CSS o JavaScript. La
interfaz de Flet se puede ejecutar localmente o desplegar en línea, y
funciona en navegadores, ventanas de aplicaciones de escritorio, o
dispositivos móviles.

Flet es especialmente útil para desarrolladores que desean una
experiencia de programación similar a Flutter, pero en Python.

*** Características de Flet
- **Componentes de UI**: Flet incluye una variedad de componentes como
  botones, cuadros de texto, listas, imágenes, íconos y más.
- **Interactividad**: Ofrece soporte para manejar eventos, como clics en
  botones y cambios de entrada de texto.
- **Adaptabilidad**: Las aplicaciones de Flet se adaptan a dispositivos
  de escritorio, móviles y tabletas, permitiendo el desarrollo de
  interfaces responsive.
- **Despliegue Web**: Las aplicaciones se pueden ejecutar en modo web,
  abriéndose directamente en un navegador.
- **Integración con Python**: Permite escribir aplicaciones completas en
  Python, sin necesidad de usar HTML, CSS o JavaScript directamente.

*** Instalación de Flet
Para instalar Flet, ejecuta el siguiente comando en la terminal:

 #+begin_src shell
 pip install flet
 #+end_src

Este comando descargará e instalará Flet y sus dependencias.

*** Ejemplos Básicos

**** Ejemplo 1: "Hola, Mundo" en Flet
Este es un ejemplo básico que muestra cómo crear una aplicación simple que muestra "Hola, Mundo".

#+begin_src python :results output :tangle code/feje1.py
import flet as ft

def main(page: ft.Page):
    page.add(ft.Text("Hola, Mundo"))

ft.app(target=main, view="web_browser")
#+end_src

#+RESULTS:
: package:media_kit_libs_linux registered.
#+RESULTS:

#+BEGIN_SRC python
import flet as ft

async def main(page: ft.Page):
    await asyncio.sleep(1)
    page.add(ft.Text("Hello, async world!"))

ft.app(main)
#+END_SRC

#+RESULTS:
: None

En este ejemplo:
- `main` es la función principal que define el contenido de la página.
- `page.add(ft.Text("Hola, Mundo"))` agrega un texto con el mensaje
  "Hola, Mundo" a la página.




** Ejemplo 2: Contador Interactivo
 Un ejemplo interactivo que implementa un contador con botones para
 incrementar y decrementar el valor.

 #+begin_src python
 import flet as ft

 def main(page: ft.Page):
     count = 0
     display = ft.Text(value=str(count), size=32)

     def increment(e):
         nonlocal count
         count += 1
         display.value = str(count)
         page.update()

     def decrement(e):
         nonlocal count
         count -= 1
         display.value = str(count)
         page.update()

     page.add(
         display,
         ft.Row([
             ft.ElevatedButton("Incrementar", on_click=increment),
             ft.ElevatedButton("Decrementar", on_click=decrement),
         ])
     )

 ft.app(target=main,  view=ft.WEB_BROWSER)
 #+end_src

 #+RESULTS:

 En este ejemplo:
 - `increment` y `decrement` son funciones que ajustan el valor del contador.
 - Los botones llaman a estas funciones cuando se hace clic, y actualizan la pantalla.

***  Ejecución de Aplicaciones en Flet
  Para ejecutar una aplicación de Flet en modo web, usa la línea
  `ft.app(target=main, view=ft.WEB_BROWSER)`. Esto abre la aplicación
  en un navegador web, ejecutándola en un servidor local en
  `http://localhost:8550`. Puedes compartir la URL o desplegar la
  aplicación en un servidor para que esté disponible en línea.



#+begin_src python :results output :tangle code/flet1.py
import flet as ft

# Función principal que define la interfaz de la app
def main(page: ft.Page):
    # Título de la ventana
    page.title = "Ejemplo básico de Flet"
    
    # Campo de texto donde el usuario puede escribir
    text_field = ft.TextField(label="Escribe algo aquí")
    
    # Label para mostrar el resultado
    result = ft.Text(value="")
    
    # Función que se ejecuta al hacer clic en el botón
    def button_clicked(e):
        result.value = f"Has escrito: {text_field.value}"  # Actualizar el texto
        page.update()  # Actualizar la página para mostrar los cambios
    
    # Botón que ejecuta la función cuando se hace clic
    button = ft.ElevatedButton(text="Mostrar texto", on_click=button_clicked)
    
    # Añadir los elementos a la página
    page.add(text_field, button, result)

# Ejecutar la app
ft.app(target=main)
#+end_src




** 3. Conversor de Temperatura
   Este conversor permite la conversión de grados Celsius a Fahrenheit y viceversa.

   #+begin_src python
   import flet as ft

   def main(page: ft.Page):
       input_temp = ft.TextField(label="Temperatura")
       result_text = ft.Text(size=24)

       def convert_to_fahrenheit(e):
           try:
               celsius = float(input_temp.value)
               fahrenheit = celsius * 9/5 + 32
               result_text.value = f"{celsius}°C = {fahrenheit:.2f}°F"
           except ValueError:
               result_text.value = "Ingresa un valor numérico válido."
           page.update()

       def convert_to_celsius(e):
           try:
               fahrenheit = float(input_temp.value)
               celsius = (fahrenheit - 32) * 5/9
               result_text.value = f"{fahrenheit}°F = {celsius:.2f}°C"
           except ValueError:
               result_text.value = "Ingresa un valor numérico válido."
           page.update()

       page.add(
           input_temp,
           ft.Row([
               ft.ElevatedButton("Convertir a °F", on_click=convert_to_fahrenheit),
               ft.ElevatedButton("Convertir a °C", on_click=convert_to_celsius),
           ]),
           result_text
       )

   ft.app(target=main)
   #+end_src

   #+RESULTS:
   : None

** 4. Lista de Tareas
Una simple lista de tareas que permite agregar y eliminar tareas.

#+begin_src python
import flet as ft

def main(page: ft.Page):
    task_input = ft.TextField(label="Nueva Tarea")
    tasks = ft.Column()

    def add_task(e):
        if task_input.value:
            new_task = ft.Row([
                ft.Text(task_input.value),
                ft.IconButton(ft.icons.DELETE, on_click=lambda _: remove_task(new_task))
            ])
            tasks.controls.append(new_task)
            task_input.value = ""
            page.update()

    def remove_task(task):
        tasks.controls.remove(task)
        page.update()

    page.add(
        task_input,
        ft.ElevatedButton("Agregar Tarea", on_click=add_task),
        tasks
    )

ft.app(target=main, view=ft.WEB_BROWSER)
#+end_src



** Calculadora 

#+BEGIN_SRC python
import flet as ft

def main(page: ft.Page):
    # Variables para almacenar los valores y la operación
    current_input = ""
    operator = ""
    first_number = None
    result_text = ft.Text(value="0", size=32)  # Pantalla de la calculadora

    # Función para actualizar la pantalla de la calculadora
    def update_display(value):
        result_text.value = value
        page.update()

    # Función que se llama cuando se presiona un número o un punto decimal
    def number_click(e):
        nonlocal current_input
        current_input += e.control.data
        update_display(current_input)

    # Función que se llama cuando se selecciona una operación (+, -, *, /)
    def operator_click(e):
        nonlocal current_input, operator, first_number
        if current_input:
            first_number = float(current_input)
            operator = e.control.data
            current_input = ""
            update_display(operator)

    # Función que se llama cuando se presiona "=" para obtener el resultado
    def calculate(e):
        nonlocal current_input, operator, first_number
        if first_number is not None and current_input:
            second_number = float(current_input)
            result = None
            if operator == "+":
                result = first_number + second_number
            elif operator == "-":
                result = first_number - second_number
            elif operator == "*":
                result = first_number * second_number
            elif operator == "/":
                if second_number != 0:
                    result = first_number / second_number
                else:
                    result = "Error"
            update_display(str(result))
            # Resetear los valores
            first_number = result if isinstance(result, (int, float)) else None
            current_input = ""

    # Función para el botón de "Clear" que resetea la calculadora
    def clear(e):
        nonlocal current_input, operator, first_number
        current_input = ""
        operator = ""
        first_number = None
        update_display("0")

    # Layout de la calculadora
    page.add(result_text)  # Pantalla de la calculadora

    # Filas de botones
    botones = [
        ["7", "8", "9", "/"],
        ["4", "5", "6", "*"],
        ["1", "2", "3", "-"],
        ["0", ".", "=", "+"],
    ]

    for fila in botones:
        row = ft.Row()
        for boton in fila:
            if boton.isdigit() or boton == ".":
                button = ft.ElevatedButton(text=boton, data=boton, on_click=number_click, width=80, height=80)
            elif boton in ["+", "-", "*", "/"]:
                button = ft.ElevatedButton(text=boton, data=boton, on_click=operator_click, width=80, height=80)
            elif boton == "=":
                button = ft.ElevatedButton(text=boton, on_click=calculate, width=80, height=80)
            row.controls.append(button)
        page.add(row)

    # Botón de limpiar
    page.add(ft.ElevatedButton(text="Clear", on_click=clear, width=320, height=80))

ft.app(target=main)

#+END_SRC

#+RESULTS:
: None


#+BEGIN_SRC python :results output :tangle code/fletaltas.py
import json
import os
import flet as ft

class Articulacion:
    def __init__(self, angulo_actual, angulo_objetivo, velocidad, limite_min, limite_max):
        self.angulo_actual = angulo_actual
        self.angulo_objetivo = angulo_objetivo
        self.velocidad = velocidad
        self.limite_min = limite_min
        self.limite_max = limite_max

    def set_angulo(self, angulo):
        if self.limite_min <= angulo <= self.limite_max:
            self.angulo_actual = angulo
            self.angulo_objetivo = angulo
        else:
            print(f"El ángulo {angulo} está fuera de los límites para esta articulación.")

class BrazoRobotico:
    def __init__(self):
        self.hombro = Articulacion(0, 0, 1, -90, 90)
        self.codo = Articulacion(0, 0, 1, 0, 135)
        self.muneca = Articulacion(0, 0, 1, -90, 90)
        self.pinza = Articulacion(0, 0, 1, 0, 180)

    def mover_a_posicion(self, posiciones_objetivo):
        self.hombro.set_angulo(posiciones_objetivo[0])
        self.codo.set_angulo(posiciones_objetivo[1])
        self.muneca.set_angulo(posiciones_objetivo[2])
        self.pinza.set_angulo(posiciones_objetivo[3])

    def obtener_posiciones(self):
        return {
            "hombro": self.hombro.angulo_actual,
            "codo": self.codo.angulo_actual,
            "muneca": self.muneca.angulo_actual,
            "pinza": self.pinza.angulo_actual
        }

class ManejoArchivos:
    def __init__(self, archivo):
        self.archivo = archivo
        if not os.path.exists(self.archivo):
            with open(self.archivo, 'w') as f:
                json.dump([], f)

    def alta(self, datos):
        with open(self.archivo, 'r') as f:
            registros = json.load(f)
        registros.append(datos)
        with open(self.archivo, 'w') as f:
            json.dump(registros, f, indent=4)

    def baja(self, indice):
        with open(self.archivo, 'r') as f:
            registros = json.load(f)
        if 0 <= indice < len(registros):
            registros.pop(indice)
        with open(self.archivo, 'w') as f:
            json.dump(registros, f, indent=4)

    def modificar(self, indice, nuevos_datos):
        with open(self.archivo, 'r') as f:
            registros = json.load(f)
        if 0 <= indice < len(registros):
            registros[indice] = nuevos_datos
        with open(self.archivo, 'w') as f:
            json.dump(registros, f, indent=4)

    def consultar(self):
        with open(self.archivo, 'r') as f:
            return json.load(f)

def main(page: ft.Page):
    brazo = BrazoRobotico()
    archivo = ManejoArchivos("articulaciones.json")
    
    # Función para mostrar posiciones
    def mostrar_posiciones():
        posiciones = archivo.consultar()
        lista_posiciones.controls.clear()
        if posiciones:
            for i, pos in enumerate(posiciones):
                lista_posiciones.controls.append(ft.Text(f"Posición {i}: Hombro={pos['hombro']}, Codo={pos['codo']}, Muñeca={pos['muneca']}, Pinza={pos['pinza']}"))
        else:
            lista_posiciones.controls.append(ft.Text("No hay posiciones guardadas."))
        limpiar_campos()
        page.update()

    # Función para limpiar campos de texto
    def limpiar_campos():
        hombro.value = ""
        codo.value = ""
        muneca.value = ""
        pinza.value = ""
        indice_baja.value = ""
        indice_modificar.value = ""

    # Funciones de alta, baja y modificación
    def alta_click(e):
        try:
            pos_hombro = float(hombro.value)
            pos_codo = float(codo.value)
            pos_muneca = float(muneca.value)
            pos_pinza = float(pinza.value)
            brazo.mover_a_posicion([pos_hombro, pos_codo, pos_muneca, pos_pinza])
            archivo.alta(brazo.obtener_posiciones())
            resultado.value = "Posición guardada exitosamente."
            mostrar_posiciones()
        except ValueError:
            resultado.value = "Error: Ingrese valores numéricos válidos."
        page.update()

    def baja_click(e):
        try:
            indice = int(indice_baja.value)
            archivo.baja(indice)
            resultado.value = "Posición eliminada exitosamente."
            mostrar_posiciones()
        except ValueError:
            resultado.value = "Error: Ingrese un índice válido."
        page.update()

    def modificar_click(e):
        try:
            indice = int(indice_modificar.value)
            pos_hombro = float(hombro.value)
            pos_codo = float(codo.value)
            pos_muneca = float(muneca.value)
            pos_pinza = float(pinza.value)
            brazo.mover_a_posicion([pos_hombro, pos_codo, pos_muneca, pos_pinza])
            archivo.modificar(indice, brazo.obtener_posiciones())
            resultado.value = "Posición modificada exitosamente."
            mostrar_posiciones()
        except ValueError:
            resultado.value = "Error: Ingrese valores numéricos válidos."
        page.update()

    # Elementos de la interfaz
    hombro = ft.TextField(label="Ángulo del hombro")
    codo = ft.TextField(label="Ángulo del codo")
    muneca = ft.TextField(label="Ángulo de la muñeca")
    pinza = ft.TextField(label="Ángulo de la pinza")
    indice_baja = ft.TextField(label="Índice para eliminar")
    indice_modificar = ft.TextField(label="Índice para modificar")
    resultado = ft.Text()
    
    # Contenedor con scroll para las posiciones guardadas
    lista_posiciones = ft.Column(scroll="adaptive")

    # Menú de opciones
    def cambiar_vista(menu_item):
        container_opciones.controls.clear()
        resultado.value = ""
        if menu_item == "Alta":
            container_opciones.controls.extend([hombro, codo, muneca, pinza, ft.ElevatedButton("Guardar Posición", on_click=alta_click)])
        elif menu_item == "Baja":
            container_opciones.controls.extend([indice_baja, ft.ElevatedButton("Eliminar Posición", on_click=baja_click)])
        elif menu_item == "Modificación":
            container_opciones.controls.extend([indice_modificar, hombro, codo, muneca, pinza, ft.ElevatedButton("Modificar Posición", on_click=modificar_click)])
        elif menu_item == "Consultas":
            mostrar_posiciones()
        limpiar_campos()
        page.update()

    # Contenedor para los menús y opciones
    container_opciones = ft.Column()
    
    # Interfaz principal
    page.add(
        ft.Text("Control de Brazo Robótico", style="headlineMedium"),
        ft.Row([ft.ElevatedButton(text="Alta", on_click=lambda e: cambiar_vista("Alta")),
                ft.ElevatedButton(text="Baja", on_click=lambda e: cambiar_vista("Baja")),
                ft.ElevatedButton(text="Modificación", on_click=lambda e: cambiar_vista("Modificación")),
                ft.ElevatedButton(text="Consultas", on_click=lambda e: cambiar_vista("Consultas"))]),
        container_opciones,
        resultado,
        ft.Text("Posiciones Guardadas:", style="headlineSmall"),
        lista_posiciones
    )

    # Inicializa con la lista de posiciones guardadas
    mostrar_posiciones()

ft.app(target=main, view="web_browser")

#+END_SRC


#+RESULTS:
: package:media_kit_libs_linux registered.


** Base de datos y flet

Ejemplo de una aplicación CRUD en Flet que usa
PostgreSQL. Este ejemplo permite realizar altas,
bajas, modificaciones y consultas en una base de datos PostgreSQL. Se
asume que tienes PostgreSQL instalado y una base de datos configurada.

*** Configuración de la Base de Datos PostgreSQL

Crea una base de datos PostgreSQL (si no la tienes).

#+BEGIN_SRC shell
psql -U postgres
CREATE DATABASE ejemplo;
#+END_SRC

Crea la tabla personas en la base de datos:

#+BEGIN_SRC sql
CREATE TABLE personas (
    id SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    edad INTEGER NOT NULL
);
#+END_SRC


** Ejemplo de CRUD (Altas, Bajas, Modificaciones y Consultas) en Flet con PostgreSQL

*** Requisitos
   Para este ejemplo, asegúrate de tener PostgreSQL configurado y los
   paquetes `psycopg2` y `flet` instalados.

*** Código de la Aplicación

   #+begin_src python
   import flet as ft
   import psycopg2

   # Configuración de conexión a PostgreSQL
   def conectar_db():
       return psycopg2.connect(
           dbname="test",
           user="postgres",
           password="postgres",  # Cambia "tu_password" a la contraseña de tu usuario
           host="192.168.1.64"
           
       )

   # Configuración inicial de la tabla
   def crear_tabla():
       conn = conectar_db()
       cursor = conn.cursor()
       cursor.execute("""
           CREATE TABLE IF NOT EXISTS personas (
               id SERIAL PRIMARY KEY,
               llave varchar(100),
               correo varchar(200),
               nombre VARCHAR(100) NOT NULL,
               edad INTEGER NOT NULL
           )
       """)
       conn.commit()
       conn.close()

   crear_tabla()  # Crea la tabla al iniciar la aplicación

   # Función principal de la aplicación en Flet
   def main(page: ft.Page):
       # Función para actualizar la lista de personas
       def actualizar_lista():
           conn = conectar_db()
           cursor = conn.cursor()
           cursor.execute("SELECT * FROM personas ")
           registros = cursor.fetchall()
           lista_personas.controls.clear()
           for registro in registros:
               lista_personas.controls.append(
                   ft.Text(f"ID: {registro[0]}, Nombre: {registro[1]}, Edad: {registro[2]}")
               )
           conn.close()
           page.update()

       # Función para agregar una persona
       def agregar_persona(e):
           nombre = nombre_input.value
           try:
               edad = int(edad_input.value)
               conn = conectar_db()
               cursor = conn.cursor()                                         
               cursor.execute("INSERT INTO personas (nombre, edad) VALUES (%s, %s)", (nombre, edad))
               conn.commit()
               conn.close()
               actualizar_lista()
               nombre_input.value = ""
               edad_input.value = ""
               resultado.value = "Persona agregada exitosamente."
           except ValueError:
               resultado.value = "Edad debe ser un número entero."
           page.update()

       # Función para eliminar una persona
       def eliminar_persona(e):
           try:
               persona_id = int(id_input.value)
               conn = conectar_db()
               cursor = conn.cursor()
               cursor.execute("DELETE FROM personas WHERE id = %s", (persona_id,))
               conn.commit()
               conn.close()
               actualizar_lista()
               id_input.value = ""
               resultado.value = "Persona eliminada exitosamente."
           except ValueError:
               resultado.value = "ID debe ser un número entero."
           page.update()

       # Función para modificar una persona
       def modificar_persona(e):
           try:
               persona_id = int(id_input.value)
               nuevo_nombre = nombre_input.value
               nueva_edad = int(edad_input.value)
               conn = conectar_db()
               cursor = conn.cursor()
               cursor.execute("UPDATE personas SET nombre = %s, edad = %s WHERE id = %s", (nuevo_nombre, nueva_edad, persona_id))
               conn.commit()
               conn.close()
               actualizar_lista()
               id_input.value = ""
               nombre_input.value = ""
               edad_input.value = ""
               resultado.value = "Persona modificada exitosamente."
           except ValueError:
               resultado.value = "ID y edad deben ser números enteros."
           page.update()

       # Elementos de la interfaz
       id_input = ft.TextField(label="ID")
       nombre_input = ft.TextField(label="Nombre")
       edad_input = ft.TextField(label="Edad")
       resultado = ft.Text()
       lista_personas = ft.Column()

       # Interfaz de usuario
       page.add(
           ft.Text("Administración de Personas", style="headlineMedium"),
           id_input,
           nombre_input,
           edad_input,
           ft.Row([
               ft.ElevatedButton("Agregar", on_click=agregar_persona),
               ft.ElevatedButton("Eliminar", on_click=eliminar_persona),
               ft.ElevatedButton("Modificar", on_click=modificar_persona),
               ft.ElevatedButton("Consultar", on_click=actualizar_lista),
           ]),
           resultado,
           ft.Text("Lista de Personas:", style="headlineSmall"),
           lista_personas
       )

       # Cargar la lista inicial de personas
       actualizar_lista()

   ft.app(target=main)
   #+end_src

   #+RESULTS:

*** Explicación del Código

   - **Conexión a PostgreSQL**: `conectar_db()` devuelve una conexión a la base de datos PostgreSQL.
   - **Funciones CRUD**:
     - `agregar_persona`: Agrega una persona usando los valores ingresados.
     - `eliminar_persona`: Elimina una persona con el ID especificado.
     - `modificar_persona`: Actualiza el nombre y la edad de la persona con el ID proporcionado.
     - `actualizar_lista`: Consulta todas las personas en la base de datos y muestra la lista en la interfaz.
   - **Campos de Entrada**: `id_input`, `nombre_input`, y `edad_input` reciben los valores necesarios para las operaciones.
   - **Display de Resultados**: `lista_personas` muestra las personas en la base de datos, y `resultado` da retroalimentación de éxito o error.

*** Ejecución
   - Guarda el código en un archivo Python.
   - Ejecuta el archivo y abre la aplicación en el navegador.
   - Interactúa con la base de datos PostgreSQL usando la interfaz en Flet.



** ¿Qué es una Base de Datos?
   Una **base de datos** es un conjunto estructurado de datos
   almacenados electrónicamente que permite organizar, gestionar y
   acceder a la información de forma eficiente. Las bases de datos se
   utilizan en una amplia variedad de aplicaciones, desde el
   almacenamiento de datos de usuarios en una aplicación hasta el
   manejo de información financiera y científica.

   Los datos en una base de datos pueden estar organizados en:
   - **Tablas** (como en bases de datos relacionales)
   - **Documentos** (como en bases de datos NoSQL)
   - **Objetos** (como en bases de datos orientadas a objetos)

*** Manejadores de Bases de Datos (DBMS - Database Management System)
   Un **DBMS (Database Management System)** o **Manejador de Bases de Datos** es un software que permite la creación, modificación y administración de bases de datos. Estos sistemas proporcionan interfaces y herramientas para interactuar con los datos y suelen incluir características avanzadas, como:
   - Control de acceso y seguridad.
   - Manejo de transacciones y consistencia.
   - Recuperación de datos y administración de copias de seguridad.
   
   Algunos DBMS conocidos son:
   - **MySQL**: Muy popular en aplicaciones web y disponible en versiones gratuitas y de pago.
   - **PostgreSQL**: Una opción avanzada, con soporte para SQL estándar y características extensas.
   - **SQLite**: Ideal para aplicaciones locales pequeñas, ya que es liviano y no requiere un servidor.
   - **Oracle**: Base de datos potente y de uso común en grandes empresas, con licenciamiento comercial.
   - **Microsoft SQL Server**: Base de datos popular en aplicaciones empresariales y Windows.

*** Tipos de Bases de Datos
   Las bases de datos se pueden clasificar en diferentes tipos según su estructura y modelo de datos:

**** Bases de Datos Relacionales (SQL)
    Las bases de datos relacionales organizan los datos en tablas con filas y columnas, usando un lenguaje de consulta estructurado, **SQL (Structured Query Language)**, para manipular los datos. Las bases de datos relacionales son ideales para aplicaciones que requieren integridad, consistencia y soporte para relaciones complejas entre tablas.

    Ejemplos: MySQL, PostgreSQL, Oracle, Microsoft SQL Server.

**** Bases de Datos NoSQL
    Las bases de datos NoSQL son diseñadas para manejar grandes cantidades de datos no estructurados o semi-estructurados. Existen varios subtipos dentro de las bases de datos NoSQL:
    - **Base de datos de documentos**: Almacenan datos en formato de documentos JSON o BSON. Ejemplo: MongoDB.
    - **Base de datos de clave-valor**: Almacenan datos como pares clave-valor. Ejemplo: Redis, DynamoDB.
    - **Base de datos de grafos**: Optimizadas para relaciones complejas entre datos, como redes sociales. Ejemplo: Neo4j.
    - **Base de datos de columnas anchas**: Usadas para grandes volúmenes de datos y análisis, como en Big Data. Ejemplo: Cassandra.

**** Bases de Datos Orientadas a Objetos
    Las bases de datos orientadas a objetos almacenan datos en forma
    de objetos, tal como en la programación orientada a objetos
    (OOP). Son útiles cuando se necesita almacenar datos complejos y
    estructurados, como en aplicaciones científicas o de ingeniería.
    
    Ejemplo: db4o (Database for Objects), ObjectDB.

**** Bases de Datos Distribuidas
    Una base de datos distribuida tiene su almacenamiento repartido en
    múltiples ubicaciones físicas, a menudo para mejorar la
    disponibilidad y la tolerancia a fallos. Estas bases de datos son
    comunes en sistemas que necesitan escalar horizontalmente y
    procesar grandes volúmenes de datos de manera paralela.

    Ejemplos: Amazon DynamoDB, Google Bigtable.

**** Bases de Datos en Memoria
    Las bases de datos en memoria almacenan todos los datos
    directamente en la RAM en lugar de en un disco, lo que permite un
    acceso rápido pero con una pérdida de datos en caso de apagado sin
    respaldo. Son útiles para sistemas que requieren tiempos de
    respuesta extremadamente rápidos.

    Ejemplos: Redis, Memcached.

*** Ejemplos en Código: Creación de Tablas en Diferentes Manejadores
   Aquí hay ejemplos básicos de creación de una tabla en algunos DBMS.

   - **SQLite**:
#+begin_src python
import sqlite3

conn = sqlite3.connect('mi_base_datos.db')
cursor = conn.cursor()
cursor.execute("""
CREATE TABLE IF NOT EXISTS usuarios (
    id INTEGER PRIMARY KEY,
    nombre TEXT,
    email TEXT
)
""")
conn.commit()
cursor.close()
conn.close()
#+end_src

   - **MySQL**:
#+begin_src python
import mysql.connector

conn = mysql.connector.connect(
    host="localhost",
    user="tu_usuario",
    password="tu_contraseña",
    database="mi_base_datos"
)
cursor = conn.cursor()
cursor.execute("""
CREATE TABLE IF NOT EXISTS usuarios (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(50),
    email VARCHAR(50)
)
""")
conn.commit()
cursor.close()
conn.close()
#+end_src

   - **MongoDB (NoSQL, Documentos)**:
#+begin_src python
from pymongo import MongoClient

client = MongoClient("mongodb://localhost:27017/")
db = client["mi_base_datos"]
usuarios = db["usuarios"]

usuario = {
    "nombre": "Juan Pérez",
    "email": "juan.perez@example.com"
}
usuarios.insert_one(usuario)
#+end_src

Las bases de datos y sus manejadores ofrecen múltiples maneras de
almacenar y gestionar datos según las necesidades del proyecto. Las
bases de datos relacionales son adecuadas para aplicaciones que
requieren relaciones entre datos, mientras que las bases de datos
NoSQL son preferibles para aplicaciones que manejan datos no
estructurados y que necesitan escalabilidad horizontal.


** Diferencias entre archivos y bases de datos en Python

*** Manejo de Archivos vs Bases de Datos
   La elección entre archivos y bases de datos depende de la
   naturaleza de los datos y de los requisitos del proyecto. A
   continuación se detallan algunas diferencias clave:

*** Almacenamiento y Organización de Datos
   - Archivos: 
     - Almacenan datos en un formato estructurado (como CSV, JSON, XML) o no estructurado (como texto plano).
     - Los datos suelen estar organizados en filas y columnas en archivos estructurados (ej., CSV).
     - Ideal para conjuntos de datos simples y de tamaño pequeño a mediano.
   - Bases de Datos:
     - Almacenan datos en tablas, organizadas en filas y columnas con relaciones bien definidas.
     - Facilitan la organización compleja de datos, con la capacidad de establecer relaciones entre tablas.
     - Escalan bien para grandes volúmenes de datos y consultas complejas.

*** Acceso y Consulta de Datos
   - Archivos:
     - Requieren leer el archivo completo o líneas específicas mediante código para encontrar datos.
     - No tienen soporte directo para consultas complejas; necesitas recorrer el archivo manualmente.
   - Bases de Datos:
     - Permiten consultas avanzadas usando SQL (Structured Query Language), que simplifica búsquedas complejas.
     - Soportan índices que aceleran la búsqueda de datos y permiten recuperar solo las filas necesarias.

*** Rendimiento
   - Archivos:
     - Adecuados para operaciones de lectura/escritura sencillas en archivos pequeños o medianos.
     - Pierden eficiencia en el acceso aleatorio a datos o cuando el archivo es demasiado grande.
   - Bases de Datos:
     - Ofrecen un alto rendimiento para grandes volúmenes de datos, especialmente cuando están bien indexadas.
     - Manejan operaciones de escritura concurrente y acceso aleatorio de manera eficiente.

*** Consistencia y Seguridad de los Datos
   - Archivos:
     - No garantizan consistencia en caso de acceso concurrente; la sobrescritura accidental es común sin un manejo adecuado.
     - No ofrecen funciones integradas de seguridad ni protección contra corrupción de datos.
   - Bases de Datos:
     - Proveen consistencia mediante transacciones y bloqueos que protegen los datos en acceso concurrente.
     - Ofrecen mecanismos de autenticación y autorización para la seguridad de los datos.

*** Escalabilidad
   - Archivos:
     - Escalabilidad limitada; la manipulación de archivos grandes puede llevar a problemas de rendimiento y a la complejidad del código.
   - Bases de Datos:
     - Altamente escalables; se pueden optimizar para manejar grandes volúmenes de datos y conexiones simultáneas.

*** Ejemplo en Código (diferencias en acceso a datos)
   - Archivo (lectura de un archivo CSV):
#+begin_src python
import csv

with open("datos.csv", mode="r") as archivo:
    lector = csv.reader(archivo)
    for fila in lector:
        print(fila)
#+end_src

   - Base de Datos (consulta de datos en SQL):
#+begin_src python
import sqlite3

conn = sqlite3.connect("mi_base_datos.db")
cursor = conn.cursor()

cursor.execute("SELECT * FROM clientes WHERE edad > 30")
resultados = cursor.fetchall()
for fila in resultados:
    print(fila)

cursor.close()
conn.close()
#+end_src

- **Archivos**: ideales para datos simples, estructuras de bajo volumen, o si no se requiere de consultas avanzadas.
- **Bases de Datos**: son preferibles para grandes volúmenes de datos, organización compleja y necesidades de acceso rápido y seguro.

** Base de Datos en Python

*** Requerimientos

Para trabajar con bases de datos en Python, necesitas instalar las
bibliotecas adecuadas según el tipo de base de datos que estés
utilizando. Python incluye *sqlite3* en su biblioteca estándar, pero
también puedes conectarte a bases de datos como MySQL o PostgreSQL
instalando bibliotecas adicionales.

Ejemplo de instalación para MySQL y PostgreSQL:
#+begin_src bash
pip install mysql-connector-python psycopg2
#+end_src

*** Conexión a la Base de Datos
Para conectarte a una base de datos, debes crear una conexión y un cursor para ejecutar consultas SQL.

**** Conexión a SQLite
SQLite es ideal para bases de datos locales pequeñas y no necesita instalación adicional.
#+begin_src python
import sqlite3

# Crear una conexión
conn = sqlite3.connect('mi_base_datos.db')
# Crear un cursor
cursor = conn.cursor()
#+end_src

**** Conexión a MySQL
Para conectarte a MySQL, asegúrate de tener instalada la biblioteca `mysql-connector-python`.
#+begin_src python
import mysql.connector

conn = mysql.connector.connect(
    host="localhost",
    user="tu_usuario",
    password="tu_contraseña",
    database="nombre_base_datos"
)
cursor = conn.cursor()
#+end_src

**** Conexión a PostgreSQL
Para PostgreSQL, necesitas la biblioteca `psycopg2`.
#+begin_src python
import psycopg2

conn = psycopg2.connect(
    host="localhost",
    user="tu_usuario",
    password="tu_contraseña",
    database="nombre_base_datos"
)
cursor = conn.cursor()
#+end_src

*** Crear una Tabla
Para almacenar datos, necesitas crear una tabla. En este ejemplo, se crea una tabla llamada "clientes" con campos como `id`, `nombre`, `edad` y `email`.

#+begin_src python
cursor.execute("""
CREATE TABLE IF NOT EXISTS clientes (
    id SERIAL PRIMARY KEY,
    nombre VARCHAR(50),
    edad INTEGER,
    email VARCHAR(50)
)
""")
conn.commit()
#+end_src

*** Insertar Datos en la Tabla
Para agregar registros a la tabla, usa `INSERT INTO`. Aquí insertamos un registro en la tabla "clientes".

#+begin_src python
cursor.execute("""
INSERT INTO clientes (nombre, edad, email)
VALUES (%s, %s, %s)
""", ("Juan Pérez", 28, "juan.perez@example.com"))
conn.commit()
#+end_src

*** Consultar Datos
Para obtener datos almacenados, utiliza `SELECT`. A continuación se presentan dos ejemplos para obtener todos los registros y para aplicar una condición de búsqueda.

**** Obtener todos los registros
#+begin_src python
cursor.execute("SELECT * FROM clientes")
resultados = cursor.fetchall()
for fila in resultados:
    print(fila)
#+end_src

**** Obtener registros con una condición
#+begin_src python
cursor.execute("SELECT * FROM clientes WHERE edad > %s", (25,))
resultados = cursor.fetchall()
for fila in resultados:
    print(fila)
#+end_src

*** Actualizar Datos
Para modificar datos existentes, usa `UPDATE`. Este ejemplo muestra cómo actualizar el `email` de un cliente específico.

#+begin_src python
cursor.execute("""
UPDATE clientes SET email = %s WHERE nombre = %s
""", ("nuevo.email@example.com", "Juan Pérez"))
conn.commit()
#+end_src

*** Eliminar Datos
Para borrar registros, utiliza `DELETE`. Aquí se muestra cómo eliminar un cliente específico.

#+begin_src python
cursor.execute("DELETE FROM clientes WHERE nombre = %s", ("Juan Pérez",))
conn.commit()
#+end_src

*** Cerrar la Conexión
Es importante cerrar la conexión a la base de datos después de realizar las operaciones.

#+begin_src python
cursor.close()
conn.close()
#+end_src

Este manual te ofrece una guía básica para el manejo de bases de datos
en Python. Puedes aplicar estas técnicas a diferentes sistemas de
bases de datos con pequeñas adaptaciones en las conexiones y las
consultas. Consulta la documentación específica de cada biblioteca
para funcionalidades avanzadas, como transacciones y manejo de
errores.



* juego flet

#+BEGIN_SRC python
import flet as ft
import threading
import time

# Variables globales para el estado del juego
jugador_pos = [50, 300]
bala_pos = [750, 310]
velocidad_bala = -5
bala_disparada = False
salto = False
salto_altura = 15
gravedad = 1
en_suelo = True
pausa = False
modo_auto = False

# Función para actualizar el juego
def actualizar_juego(page):
    global jugador_pos, bala_pos, velocidad_bala, bala_disparada, salto, salto_altura, en_suelo, pausa
    
    while True:
        if not pausa:
            if salto:
                jugador_pos[1] -= salto_altura
                salto_altura -= gravedad
                if jugador_pos[1] >= 300:
                    jugador_pos[1] = 300
                    salto = False
                    salto_altura = 15
                    en_suelo = True
            if bala_disparada:
                bala_pos[0] += velocidad_bala
                if bala_pos[0] < 0:
                    bala_pos = [750, 310]
                    bala_disparada = False

            # Actualización visual en Flet
            page.controls[0].controls[1].top = jugador_pos[1]
            page.controls[0].controls[2].left = bala_pos[0]
            page.update()
        time.sleep(0.03)

# Función principal de Flet
def main(page):
    global salto, en_suelo, pausa, bala_disparada, velocidad_bala
    
    page.title = "Juego Flet-Pygame"
    
    # Crear contenedores para los objetos del juego
    fondo = ft.Container(width=800, height=400, bgcolor=ft.colors.BLUE_GREY_900)
    jugador = ft.Container(width=32, height=48, bgcolor=ft.colors.GREEN, top=jugador_pos[1], left=jugador_pos[0])
    bala = ft.Container(width=16, height=16, bgcolor=ft.colors.RED, top=bala_pos[1], left=bala_pos[0])
    
    # Agregar los contenedores a la página
    fondo.content = [jugador, bala]
    page.add(fondo)

    # Crear un hilo para manejar la lógica del juego
    juego_thread = threading.Thread(target=actualizar_juego, args=(page,), daemon=True)
    juego_thread.start()

    # Eventos de Flet
    def manejar_tecla(e):
        global salto, en_suelo, bala_disparada, velocidad_bala, pausa

        if e.key == " " and en_suelo and not pausa:
            salto = True
            en_suelo = False
        elif e.key == "p":
            pausa = not pausa
        elif e.key == "q":
            page.window_destroy()
        elif e.key == "d" and not bala_disparada:
            bala_disparada = True
            velocidad_bala = random.randint(-8, -3)

    page.on_keyboard_event = manejar_tecla
    page.update()

ft.app(target=main)

#+END_SRC

#+RESULTS:
: None



